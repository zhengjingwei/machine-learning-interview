[TOC]

# 一、机器学习相关

## 1、基本概念

- [x] [1-1  简述解决一个机器学习问题时，你的流程是怎样的？](#1-1)

- [x] [1-2  损失函数是什么，如何定义合理的损失函数？](#1-2)

- [ ] [1-3  回归模型和分类模型常用损失函数有哪些？各有什么优缺点](#1-3)

- [ ] [1-4  什么是结构误差和经验误差？训练模型的时候如何判断已经达到最优？](#1-4)

- [ ] [1-5  模型的“泛化”能力是指？如何提升模型泛化能力？](#1-5)

- [x] [1-6  如何选择合适的模型评估指标？AUC、精准度、召回率、F1值都是什么？如何计算？有什么优缺点？](#1-6)

- [x] [1-7  什么是混淆矩阵？](#1-7)

- [x] [1-8  ROC曲线如何绘制？相比P-R曲线有什么特点？](#1-8)

- [x] [1-9  如何评判模型是过拟合还是欠拟合？遇到过拟合或欠拟合时，你是如何解决？](#1-9)

- [ ] [1-10  你是如何针对应用场景选择合适的模型？](#1-10)

- [x] [1-11  如何选择模型中的超参数？有什么方法，并说说其优劣点](#1-11)

- [ ] [1-12  误差分析是什么？你是如何进行误差分析？](#1-12)

- [ ] [1-13  你是如何理解模型的偏差和方差？什么样的情况是高偏差，什么情况是高方差？](#1-13)

- [ ] [1-14  出现高偏差或者高方差的时候你有什么优化策略？](#1-14)

- [ ] [1-15  奥卡姆剃刀定律是什么？对机器学习模型优化有何启发？举例说明](#1-15)

- [x] [1-16  线性模型和非线性模型的区别？哪些模型是线性模型，哪些模型是非线性模型？](#1-16)

- [ ] [1-17  生成式模型和判别式模型的区别？哪些模型是生成式模型，哪些模型是判别式模型？](#1-17)



## 2、经典机器学习

### **特征工程**

- [ ] [2-1-1  你是怎样理解“特征”？](#2-1-1)

- [ ] [2-1-2  给定场景和问题，你如何设计特征？（特征工程方法论）](#2-1-2)

- [ ] [2-1-3  开发特征时候做如何做数据探索，怎样选择有用的特征？](#2-1-3)

- [ ] [2-1-4  你是如何做数据清洗的？举例说明](#2-1-4)

- [ ] [2-1-5  如何发现数据中的异常值，你是如何处理？](#2-1-5)

- [ ] [2-1-6  缺失值如何处理？](#2-1-6)

- [ ] [2-1-7  对于数值类型数据，你会怎样处理？为什么要做归一化？归一化有哪些方法？离散些方法，离散化和归一化有哪些优缺点？](#2-1-7)

- [ ] [2-1-8  标准化和归一化异同？](#2-1-8)

- [ ] [2-1-9  你是如何处理CTR类特征？](#2-1-9)

- [ ] [2-1-10  讲解贝叶斯平滑原理？以及如何训练得到平滑参数](#2-1-10)

- [ ] [2-1-11  类别型数据你是如何处理的？比如游戏品类，地域，设备](#2-1-11)

- [ ] [2-1-12  序号编码、one-hot编码、二进制编码都是什么？适合怎样的类别型数据？](#2-1-12)

- [ ] [2-1-13  时间类型数据你的处理方法是什么？原因？](#2-1-13)

- [ ] [2-1-14  你怎样理解组合特征？举个例子，并说明它和单特征有啥区别](#2-1-14)

- [ ] [2-1-15  如何处理高维组合特征？比如用户ID和内容ID？](#2-1-15)

- [ ] [2-1-16  如何理解笛卡尔积、外积、内积？](#2-1-16)

- [ ] [2-1-17  文本数据你会如何处理？](#2-1-17)

- [ ] [2-1-18  文本特征表示有哪些模型？他们的优缺点都是什么？](#2-1-18)

- [ ] [2-1-19  讲解TFF原理，它有什么优点和缺点？针对它的缺点，你有什么优化思路？](#2-1-19)

- [ ] [2-1-20  N-gram算法是什么？有什么优缺点？](#2-1-20)

- [ ] [2-1-21  讲解一下word2vec工作原理？损失函数是什么？](#2-1-21)

- [ ] [2-1-22  讲解一下LDA模型原理和训练过程？](#2-1-22)

- [ ] [2-1-23  Word2vec和LDA两个模型有什么区别和联系？](#2-1-23)

- [ ] [2-1-24  Skin-gram和cbow有何异同？](#2-1-24)

- [ ] [2-1-25  图像数据如何处理？有哪些常用的图像特征提取方法](#2-1-25)

- [ ] [2-1-26  你是怎样做特征选择的？卡方检验、信息值（IV）、VOE都是如何计算？](#2-1-26)

- [ ] [2-1-27  计算特征之间的相关性方法有哪些？有什么优缺点](#2-1-27)



**基础算法原理和推导**

**KNN**

- [x] [2-2-1  Knn建模流程是怎样的？](#2-2-1)

- [x] [2-2-2  Knn优缺点是什么？](#2-2-2)

- [x] [2-2-3  Knn适合什么样的场景和数据类型？](#2-2-3)

- [x] [2-2-4  常用的距离衡量公式都有哪些？具体说明它们的计算流程，以及使用场景？](#2-2-4)

- [x] [2-2-5  超参数K值过大或者过小对结果有什么影响，你是如何选择K值？](#2-2-5)

- [x] [2-2-6  介绍一下Kd树？如何建树，以及如何搜索最近节点？](#2-2-6)

  ·

**支持向量机**

- [ ] [2-3-1  简单讲解SVM模型原理？](#2-3-1)

- [ ] [2-3-2  SVM为什么会对缺失值敏感？实际应用时候你是如何处理？](#2-3-2)

- [ ] [2-3-3  SVM为什么可以分类非线性问题？](#2-3-3)

- [ ] [2-3-4  常用的核函数有哪些？你是如何选择不同的核函数的？](#2-3-4)

- [ ] [2-3-5  RBF核函数一定线性可分么？为什么](#2-3-5)

- [ ] [2-3-6  SVM属于线性模型还是非线性模型？为什么？](#2-3-6)

- [ ] [2-3-7  训练误差为0的SVM分类器一定存在吗？说明原因？](#2-3-7)



**朴素贝叶斯模型**

- [ ] [2-4-1  讲解贝叶斯定理？](2-4-1)

- [ ] [2-4-2  什么是条件概率、边缘概率、联合概率？](#2-4-2)

- [ ] [2-4-3  后验概率最大化的含义是什么？](#2-4-3)

- [ ] [2-4-4  朴素贝叶斯模型如何学习的？训练过程是怎样？](#2-4-4)

- [ ] [2-4-5  你如何理解生成模型和判别模型？](#2-4-5)

- [ ] [2-4-6  朴素贝叶斯模型“朴素”体现在哪里？存在什么问题？有哪些优化方向？](#2-4-6)

- [ ] [2-4-7  什么是贝叶斯网络？它能解决什么问题？](#2-4-7)

- [ ] [2-4-8  为什么说朴素贝叶斯也是线性模型而不是非线性模型呢？](#2-4-8)



**线性回归**

- [ ] [2-5-1  线性回归的基本思想是？](#2-5-1)

- [ ] [2-5-2  什么是“广义线性模型”？](#2-5-2)

- [ ] [2-5-3  线性回归常用的损失函数有哪些？优化算法有哪些？](#2-5-3)

- [ ] [2-5-4  线性回归适用什么类型的问题？有哪些优缺点？](#2-5-4)

- [ ] [2-5-5  请用最小二乘法推倒参数更新公式？](#2-5-5)



**逻辑回归**

- [ ] [2-6-1  逻辑回归相比于线性回归有什么异同？](#2-6-1)

- [ ] [2-6-2  逻辑回归和广义线性模型有何关系？](#2-6-2)

- [ ] [2-6-3  逻辑回归如何处理多标签分类？](#2-6-3)

- [ ] [2-6-4  为什么逻辑回归需要进行归一化或者取对数？](#2-6-4)

- [ ] [2-6-5  为什么逻辑回归把特征离散化之后效果会提升？](#2-6-5)

- [ ] [2-6-6  类别不平衡问题你是如何处理的？什么是过采样，什么是欠采样？举例](#2-6-6)

- [ ] [2-6-7  讲解L1和L2正则，它们都有什么作用，解释为什么L1比L2更容易产生稀疏解；对于存在线性相关的一组特征，L1正则如何选择特征？](#2-6-7)

- [ ] [2-6-8  使用交叉熵作为损失函数，梯度下降作为优化方法，推倒参数更新公式](#2-6-8)

- [ ] [2-6-9  代码写出训练函数](#2-6-9)



**FM模型**

- [ ] [2-7-1  FM模型与逻辑回归相比有什么优缺点？](#2-7-1)

- [ ] [2-7-2  为什么FM模型计算复杂度时O(kn)？](#2-7-2)

- [ ] [2-7-3  介绍FFM场感知分解机器（Field-aware Factorization Machine），说说与FM异同？](#2-7-3)

- [ ] [2-7-4  使用FM进行模型训练时候，有哪些核心参数对模型效果影响大？](#2-7-4)

- [ ] [2-7-5  如何从神经网络的视角看待FM模型？](#2-7-5)



**决策树**

- [x] [2-8-1  讲解完成的决策树的建树过程](#2-8-1)

- [x] [2-8-2  你是如何理解熵？从数学原理上解释熵公式可以作为信息不确定性的度量？](#2-8-2)

- [x] [2-8-3  联合熵、条件熵、KL散度、信息增益、信息增益比、gini系数都是什么？如何计算？](#2-8-3)

- [x] [2-8-4  常用的决策树有哪些？ID3、C4.5、CART有啥异同？](#2-8-4)

- [x] [2-8-5  决策树如何防止过拟合？前剪枝和后剪枝过程是怎样的？剪枝条件都是什么](#2-8-5)



**随机森林（RF）**

- [ ] [2-9-1  介绍RF原理和思想](#2-9-1)
- [ ] [2-9-2  RF是如何处理缺失值？](#2-9-2)
- [ ] [2-9-3  RF如何衡量特征重要度？](#2-9-3)
- [ ] [2-9-4  RF“随机”主要体现在哪里？](#2-9-4)
- [ ] [2-9-5  RF有哪些优点和局限性？](#2-9-5)
- [ ] [2-9-6  为什么多个弱分类器组合效果会比单个要好？如何组合弱分类器可以获得更好的结果？原因是什么？](#2-9-6)
- [x] [2-9-7  Bagging的思想是什么？它是降低偏差还是方差，为什么？](#2-9-7)
- [x] [2-9-8  可否将RF的基分类模型由决策树改成线性模型或者knn？为什么？](#2-9-8)



**GBDT**

- [x] [2-10-1  梯度提升和梯度下降有什么区别和联系？](#2-10-1)

- [x] [2-10-2  你是如何理解Boosting和Bagging？他们有什么异同？](#2-10-2)

- [ ] [2-10-3  讲解GBDT的训练过程？](#2-10-3)

- [ ] [2-10-4  你觉得GBDT训练过程中哪些环节可以平行提升训练效率？](#2-10-4)

- [x] [2-10-5  GBDT的优点和局限性有哪些？](#2-10-5)

- [ ] [2-10-6  GBDT是否对异常值敏感，为什么？](#2-10-6)

- [ ] [2-10-7  如何防止GBDT过拟合？](#2-10-7)

- [ ] [2-10-8  在训练过程中哪些参数对模型效果影响比较大？这些参数造成影响是什么？](#2-10-8)



**k-means**

- [ ] [2-11-1  简述kmeans建模过程？](#2-11-1)

- [ ] [2-11-2  Kmeans损失函数是如何定义？](#2-11-2)

- [ ] [2-11-3  你是如何选择初始类族的中心点？](#2-11-3)

- [ ] [2-11-4  如何提升kmeans效率？](#2-11-4)

- [ ] [2-11-5  常用的距离衡量方法有哪些？他们都适用什么类型问题？](#2-11-5)

- [ ] [2-11-6  Kmeans对异常值是否敏感？为什么？](#2-11-6)

- [ ] [2-11-7  如何评估聚类效果？](#2-11-7)

- [ ] [2-11-8  超参数类的个数k如何选取？](#2-11-8)

- [ ] [2-11-9  Kmeans有哪些优缺点？是否有了解过改进的模型，举例说明？](#2-11-9)

- [ ] [2-11-10  试试证明kmeans算法的收敛性](#2-11-10)

- [ ] [2-11-11  除了kmeans聚类算法之外，你还了解哪些聚类算法？简要说明原理](#2-11-11)



**PCA降维**

- [ ] [2-12-1  为什么要对数据进行降维？它能解决什么问题？](#2-12-1)

- [ ] [2-12-2  你是如何理解维度灾难？](#2-12-1)

- [ ] [2-12-3  PCA主成分分析思想是什么？](#2-12-1)

- [ ] [2-12-4  如何定义主成分？](#2-12-1)

- [ ] [2-12-5  如何设计目标函数使得降维达到提取主成分的目的？](#2-12-1)

- [ ] [2-12-6  PCA有哪些局限性？如何优化](#2-12-1)

- [ ] [2-12-7  线性判别分析和主成分分析在原理上有何异同？在目标函数上有何区别和联系？](#2-12-1)



**3、 深度学习**

**DNN**

- [ ] [3-1-1  描述一下神经网络？推倒反向传播公式？](#3-1-1)

- [x] [3-1-2  讲解一下dropout原理？](#3-1-2)

- [ ] [3-1-3  梯度消失和梯度膨胀的原因是什么？有什么方法可以缓解？](#3-1-3)

- [ ] [3-1-4  什么时候该用浅层神经网络，什么时候该选择深层网络](#3-1-4)

- [ ] [3-1-5  Sigmoid、Relu、Tanh激活函数都有哪些优缺点？](#3-1-5)

- [ ] [3-1-6  写出常用激活函数的导数](#3-1-6)

- [ ] [3-1-7  训练模型的时候，是否可以把网络参数全部初始化为0？为什么](#3-1-7)

- [ ] [3-1-8  Batchsize大小会如何影响收敛速度？](#3-1-8)



**CNN**

- [ ] [3-2-1  简述CNN的工作原理？](#3-2-1)

- [ ] [3-2-2  卷积核是什么？选择大卷积核和小卷积核有什么影响？](#3-2-2)

- [ ] [3-2-3  你在实际应用中如何设计卷积核？](#3-2-3)

- [ ] [3-2-4  为什么CNN具有平移不变性？](#3-2-4)

- [ ] [3-2-5  Pooling操作是什么？有几种？作用是什么？](#3-2-5)

- [ ] [3-2-6  为什么CNN需要pooling操作？](#3-2-6)

- [ ] [3-2-7  什么是batchnormalization？它的原理是什么？在CNN中如何使用？](#3-2-7)

- [x] [3-2-8  卷积操作的本质特性包括稀疏交互和参数共享，具体解释这两种特性以其作用？](#3-2-8)

- [ ] [3-2-9  你是如何理解fine-tune？有什么技巧](#3-2-9)

 

**RNN**

- [ ] [3-3-1  简述RNN模型原理，说说RNN适合解决什么类型问题？为什么](#3-3-1)

- [ ] [3-3-2  RNN和DNN有何异同？](#3-3-2)

- [ ] [3-3-3  RNN为什么有记忆功能？](#3-3-3)

- [ ] [3-3-4  长短期记忆网络LSTM是如何实现长短期记忆功能的？](#3-3-4)

- [ ] [3-3-5  长短期记忆网络LSTM各模块都使用什么激活函数，可以使用其他激活函数么？](#3-3-5)

- [ ] [3-3-6  GRU和LSTM有何异同](#3-3-6)

- [ ] [3-3-7  什么是Seq2Seq模型？该模型能解决什么类型问题？](#3-3-7)

- [ ] [3-3-8  注意力机制是什么？Seq2Seq模型引入注意力机制主要解决什么问题？](#3-3-8)

**4、 基础工具**

**Spark**

- [ ] [4-1-1  什么是宽依赖，什么是窄依赖？哪些算子是宽依赖，哪些是窄依赖？](#4-1-1)

- [ ] [4-1-2  Transformation和action算子有什么区别？举例说明](#4-1-2)

- [ ] [4-1-3  讲解sparkshuffle原理和特性？shuffle write 和 huffleread过程做些什么？](#4-1-1)

- [ ] [4-1-4  哪些spark算子会有shuffle？](#4-1-1)

- [ ] [4-1-5  讲解sparkschedule（任务调度）？](#4-1-1)

- [ ] [4-1-6  Sparkstage是如何划分的？](#4-1-1)

- [ ] [4-1-7  Sparkcache一定能提升计算性能么？说明原因？](#4-1-1)

- [ ] [4-1-8  Cache和persist有什么区别和联系？](#4-1-1)

- [ ] [4-1-9  RDD是弹性数据集，“弹性”体现在哪里呢？你觉得RDD有哪些缺陷？](#4-1-1)

- [ ] [4-1-10  当GC时间占比很大可能的原因有哪些？对应的优化方法是？](#4-1-1)

- [ ] [4-1-11  park中repartition和coalesce异同？coalesce什么时候效果更高，为什么](#4-1-1)

- [ ] [4-1-12  Groupbykey和reducebykey哪个性能更高，为什么？](#4-1-1)

- [ ] [4-1-13  你是如何理解caseclass的？](#4-1-1)

- [ ] [4-1-14  Scala里trait有什么功能，与class有何异同？什么时候用trait什么时候用class](#4-1-1)

- [ ] [4-1-15  Scala 语法中to 和 until有啥区别](#4-1-1)

- [ ] [4-1-16  讲解Scala伴生对象和伴生类](#4-1-1)





**Xgboost**

- [x] [4-2-1  你选择使用xgboost的原因是什么？](#4-2-1)

- [x] [4-2-2  Xgboost和GBDT有什么异同？](#4-2-2)

- [x] [4-2-3  为什么xgboost训练会那么快，主要优化点事什么？](#4-2-3)

- [x] [4-2-4  Xgboost是如何处理缺失值的？](#4-2-4)

- [x] [4-2-5  Xgboost和lightGBM有哪些异同？](#4-2-5)

- [x] [4-2-6  Xgboost为什么要使用泰勒展开式，解决什么问题？](#4-2-6)

- [x] [4-2-7  Xgboost是如何寻找最优特征的？](#4-2-7)



**Tensorflow**

- [ ] [4-3-1  使用tensorflow实现逻辑回归，并介绍其计算图](#4-3-1)

- [ ] [4-3-2  sparse_softmax_cross_entropy_with_logits和softmax_cross_entropy_with_logits有何异同？](#4-3-2)

- [ ] [4-3-3  使用tensorflow过程中，常见调试哪些参数？举例说明](#4-3-3)

- [ ] [4-3-4  Tensorflow梯度更新是同步还是异步，有什么好处？](#4-3-4)

- [ ] [4-3-5  讲解一下TFRecords](#4-3-5)

- [ ] [4-3-6  tensorflow如何使用如何实现超大文件训练？](#4-3-6)

- [ ] [4-3-7  如何读取或者加载图片数据？](#4-3-7)



**5、推荐系统**

- [ ] [5-1-1  你是如何选择正负样本？如何处理样本不均衡的情况？](#5-1-1)

- [ ] [5-1-2  如何设计推荐场景的特征体系？举例说明](#5-1-1)

- [ ] [5-1-3  你是如何建立用户模型来理解用户，获取用户兴趣的？](#5-1-1)

- [ ] [5-1-4  你是如何选择适合该场景的推荐模型？讲讲你的思考过程](#5-1-1)

- [ ] [5-1-5  你是如何理解当前流行的召回->粗排->精排的推荐架构？这种架构有什么优缺点？什么场景适用使用，什么场景不适合？](#5-1-1)

- [ ] [5-1-6  如何解决热度穿透的问题？（因为item热度非常高，导致ctr类特征主导排序，缺少个性化的情况）](#5-1-1)

- [ ] [5-1-7  用户冷启动你是如何处理的？](#5-1-1)
- [ ] [5-1-8  新内容你是如何处理的？](#5-1-1)

- [ ] [5-1-9  你们使用的召回算法有哪些？如何能保证足够的召回率？](#5-1-1)

- [ ] [5-1-10  实时数据和离线数据如何融合？工程上是怎样实现？如何避免实时数据置信度不高带来的偏差问题？](#5-1-1)

- [ ] [5-1-11  你们是如何平衡不同优化目标的问题？比如：时长、互动等](#5-1-1)

- [ ] [5-1-12  不同类型内容推荐时候，如何平衡不同类型内容，比如图文、视频；或者不同分类](#5-1-1)

- [ ] [5-1-13  如何保证线上线下数据一致性？工程上是如何实现？](#5-1-1)

- [ ] [5-1-14  离线训练效果好，但是上线效果不明显或在变差可能是什么问题？如何解决？](#5-1-1)

- [ ] [5-1-15  在实际业务中，出现badcase,你是如何快速反查问题的？举例说明](#5-1-1)

- [ ] [5-1-16  使用ctr预估的方式来做精排，会不会出现相似内容大量聚集？原因是什么？你是如何解决的？](#5-1-1)

- [ ] [5-1-17  你了解有多少种相关推荐算法？各有什么优缺点](#5-1-1)

- [ ] [5-1-18  深度学习可以应用到推荐问题上解决哪些问题？为什么比传统机器学习要好？](#5-1-1)



**二、数学相关**

**6、 概率论和统计学**

- [ ] [6-1-1  说说你是怎样理解信息熵的？](#6-1-1)
- [ ] [6-1-2   能否从数据原理熵解析信息熵可以表示随机变量的不确定性？](#6-1-2)
- [ ] [6-1-3  怎样的模型是最大熵模型？它有什么优点](#6-1-3)
- [ ] [6-1-4  什么是Beta分布？它与二项分布有什么关系？](#6-1-4)
- [ ] [6-1-5   什么是泊松分布？它与二项分布有什么关系？](#6-1-5)
- [ ] [6-1-6  什么是t分布？他与正态分布有什么关系？](#6-1-6)
- [ ] [6-1-7    什么是多项式分布？具体说明？](#6-1-7)
- [ ] [6-1-8   参数估计有哪些方法？](#6-1-8)
- [ ] [6-1-9  点估计和区间估计都是什么？](#6-1-9)
- [ ] [6-1-10  讲解一下极大似然估计，以及适用场景？](#6-1-10)
- [ ] [6-1-11  讲解一下最大后验概率估计，以及适用场景？极大似然估计和最大后验概率估计的区别](#6-1-10)



7、 最优化问题

- [ ] [7-1-1  什么是梯度？](#7-1-1)

- [ ] [7-1-2  梯度下降找到的一定是下降最快的方法？](#7-1-1)

- [ ] [7-1-3  牛顿法和梯度法有什么区别？](#7-1-1)

- [ ] [7-1-4  什么是拟牛顿法？](#7-1-1)

- [ ] [7-1-5  讲解什么是拉格朗日乘子法、对偶问题、kkt条件?](#7-1-1)

- [ ] [7-1-6  是否所有的优化问题都可以转化为对偶问题？](#7-1-1)

- [ ] [7-1-7  讲解SMO（SequentialMinimalOptimization）算法基本思想？](#7-1-1)

- [ ] [7-1-8  为什么深度学习不用二阶优化？](#7-1-1)

- [ ] [7-1-9  讲解SGD，ftrl、Adagrad，Adadelta，Adam，Adamax，Nadam优化算法以及他们的联系和优缺点](#7-1-1)

- [ ] [7-1-10 为什么batch size大，训练速度快or为什么mini-batch比SGD快？](#7-1-10)

- [ ] [7-1-11  为什么不把batch size设得特别大](#7-11)









# 解答

## **一、机器学习相关**

## **1、基本概念**

- [ ] <span id="1-1">1-1 简述解决一个机器学习问题时，你的流程是怎样的？</span>

  1. 确定问题：有监督问题还是无监督问题？回归问题还是分类问题？
  2. 数据收集与处理
  3. 特征工程：包括特征构建、特征选择、特征组合等
  4. 模型训练、调参、评估：包括模型的选择，选择最优的参数
  5. 模型部署：模型在线上运行的效果直接决定模型的成败

- [ ] [1-2  损失函数是什么，如何定义合理的损失函数？](#1-2)

  机器学习模型关于单个样本的预测值与真实值的差称为**损失**。用于计算损失的函数称为**损失函数**。损失函数是$f(x)$和$y$的非负实值函数函数。

- [ ] [1-3  回归模型和分类模型常用损失函数有哪些？各有什么优缺点](#1-3)

  回归模型常用的损失函数有：

  1. 0-1损失函数：
     $$
     L(f(x),y) =
     \begin{cases}
  1,
     &
     y \neq f(x) \\
     0,
     &
     y = f(x)
     \end{cases}
     $$
     
  2. 绝对损失函数：异常点多的情况下鲁棒性好；但不方便求导
     $$
     L(f(x), y) = |f(x)-y|
     $$
  
3. 平方损失函数：求导方便，能够用梯度下降法优化；对异常值敏感
     $$
     L(f(x),y) = (f(x)-y)^2
     $$
  
4. 对数损失函数/对数似然损失函数：
     $$
     L(P(Y|X),Y) = -{\rm log} P(Y|X)
     $$
  
5. Huber 损失函数：结合了绝对损失函数和平方损失函数的优点；缺点是需要调整超参数  $\delta$ 
     $$
     L_{Huber}(f, y) =
     \begin{cases}
     (f-y)^2
     &
     |f-y| \leq \delta
     \\
     2 \delta |f-y| - \delta^2
     &
     |f-y| > \delta
     \end{cases}
     $$
  
6. Log-Cosh 损失函数：具有Huber的所有优点，同时二阶处处可微（牛顿法要求二阶可微）
     $$
     L(f,y) = \log \cosh(f-y)
     $$



- [ ] [1-4  什么是结构误差和经验误差？训练模型的时候如何判断已经达到最优？](#1-4)

经验风险（经验损失）：模型 $f(X)$关于训练数据集的平均损失
$$
R_{\rm emp}(f) = \frac{1}{N} \sum_{i=1}^N L(y_i,f(x_i))
$$
结构风险：是在经验风险上加上表示模型复杂度的正则化项
$$
R_{\rm srm}(f) = \frac{1}{N} \sum_{i=1}^{N}L(y_i,f(x_i))+\lambda J(f) 
$$
经验风险最小化的策略认为，经验风险最小的模型是最优的模型。

结构风险最小化是为了防止过拟合而提出的，结构风险最小化等价于正则化。结构风险最小化的策略认为结构风险最小的模型是最优的模型。



- [ ] [1-5  模型的“泛化”能力是指？如何提升模型泛化能力？](#1-5)

通常将模型对未知数据的预测能力称为泛化能力（generalization ability）。现实中采用最多的方法是通过测试误差来评价学习方法的泛化能力。

- [ ] [1-6  如何选择合适的模型评估指标？AUC、精准度、召回率、F1值都是什么？如何计算？有什么优缺点？](#1-6)

**TP**：将正类预测为正类数

**FN**：将正类预测为负类数

**FP**：将负类预测为正类数

**TN**：将负类预测为负类数

${\color\red 分类任务指标}$

**Accuracy**（准确率）：分类正确的样本占总样本个数的比例
$$
Accuracy = \frac{n_{correct}}{n_{total}}
$$
- 缺点：不同类别的样本比例非常不均衡时，占比大的类别往往成为影响准确率的最主要因素。比如，当负样本占99%时，分类器把所有样本都预测为负样本也可以获得99%的准确率。
- 解决：可以使用每个类别下的样本准确率的算术平均（平均准确率）作为模型评估的指标。

**Precision**（精确率）：分类正确的正样本个数占分类器判定为正样本的样本个数的比例
$$
Precision = \frac{TP}{TP+FP}
$$
**Recall**（召回率）：分类正确的正样本数占真正的正样本个数的比例
$$
Recall = \frac{TP}{TP+FN}
$$
**F1-score**：precision和recall的调和平均值；当精确率和召回率都高时，F1值也会高
$$
{\rm F1} = \frac{2 \times precision \times recall}{precision + recall}
$$
在排序问题中，通常没有一个确定的阈值把得到的结果直接判定为正样本或负样本，而是采用Top N返回结果的Precision和Recall值来衡量排序模型的性能。即认为模型返回的Top N结果就是模型判定的正样本，计算前N个位置的Precision@N和Recall@N。为了综合评估一个排序模型的好坏，不仅要看模型在不同Top N下的Precision@N和Recall@N，而且最好画出模型的P-R曲线。P-R曲线的横轴是Recall，纵轴是Precision。

**ROC**：横坐标为假阳性率（False Positive Rate，FPR）；纵坐标为真阳性率（True Positive Rate，TPR）
$$
FPR = \frac{FP}{N} \\
TPR = \frac{TP}{P}
$$
其中P是真实的正样本的数量，N是真实的负样本的数量，TP是P个正样本中被分类器预测为正样本的个数，FP是N个负样本中被预测为正样本的个数。

【如何绘制ROC曲线】通过不断移动分类器的“截断点”来生成曲线上的一组关键点。在二分类问题中，模型输出一般是预测样本为正例的概率，在输出最终的正例负例之前，我们需要制定一个阈值。大于该阈值的样本判定为正例，小于该阈值的样本判定为负例。通过动态调整截断点，绘制每个截断点对应位置，再连接所有点得到最终的ROC曲线。

**AUC**：ROC曲线下的面积大小。计算AUC值只要沿着ROC横轴做积分就可以。AUC取值一般在0.5~1之间。AUC越大，分类性能越好。



${\color\red 回归任务指标}$

**RMSE**：计算预测值和实际值的平均误差
$$
{\rm RMSE} = \sqrt{\frac{\sum_{i=1}^n (y_i-\hat{y}_i)^2}{n}}
$$




- [ ] [1-7  什么是混淆矩阵？](#1-7)

  混淆矩阵，又称误差矩阵，就是分别统计分类模型归错类，归对类的观测值个数，然后把结果放在一个表里展示出来。这个表就是混淆矩阵。

  混淆矩阵是ROC曲线绘制的基础，同时它也是衡量分类型模型准确度中最基本，最直观，计算最简单的方法。

   

  | 混淆矩阵 |   预测结果   |   预测结果   |
  | :------: | :----------: | :----------: |
  | 真实情况 |     反例     |     正例     |
  |   反例   | TN（真反例） | FP（假正例） |
  |   正例   | FN（假反例） | TP（真正例） |


  - TN：True Negative，被判定为负样本，事实上也是负样本

  - FP：False Positive，被判定为正样本，但事实上是负样本

  - FN：False Negative，被判定为负样本，但事实上是正样本

  - TP：True Positive，被判定为正样本，事实上也是正样本

- [ ] [1-8  ROC曲线如何绘制？相比P-R曲线有什么特点？](#1-8)

  ROC曲线的纵轴为TPR，横轴为FPR，曲线上每个点对应一个TPR和FPR。通过调整模型阈值可以得到一个个点，从而将各个点连起来即可得到ROC曲线。

  一般情况下，PR曲线易受样本数量的影响，样本数量不均衡情况下PR曲线会有明显变化，故一般使用ROC曲线。

- [ ] [1-9  如何评判模型是过拟合还是欠拟合？遇到过拟合或欠拟合时，你是如何解决？](#1-9)

过拟合是指学习时选择的模型所包含的参数过多，以至出现这一模型对已知数据预测得很好，但对未知数据预测得很差的现象。

当训练集效果差，欠拟合（如accuracy<0.8）；训练集效果好，测试集效果差，过拟合

**欠拟合解决方法：**

1. 增加特征
2. 提高模型复杂度：神经网络提高神经元数、增加层数；SVM使用核函数；
3. 减小正则项的系数

**过拟合解决方法：**

1. 提高样本数量 ：
   - 神经网络：Data Augmentation（数据增强）
2. 简化模型：
   - 神经网络使用 Dropout、Early Stopping
   - 决策树剪枝、限制树的深度
3. 加入正则化项（L1或L2）或提高惩罚系数
4. 使用集成学习



- [ ] [1-10  你是如何针对应用场景选择合适的模型？](#1-10)
- [ ] [1-11  如何选择模型中的超参数？有什么方法，并说说其优劣点](#1-11)

超参搜索算法一般包括的要素（1）目标函数（2）搜索范围，上限和下限缺点（3）其他参数，如搜索步长。

1. **网格搜索**

查找搜索范围内所有的点来确定最优值；实际应用中先用较大搜索范围和较大步长，寻找全局最优值可能位置；然后逐步缩小搜索范围和搜索步长，寻找更精确位置。

- 优点
  - 简单
  - 如果采用较大的搜索范围和较小步长，有很大概率找到全局最优值
- 缺点
  - 耗时
  - 目标函数非凸时，可能错过全局最优解

2. **随机搜索**

不再测试上界和下界之间的所有值，而是在搜索范围中随机选取样本点。如果样本点集足够大，通过随机搜索也能大概率找到全局最优解或其近似。

- 优点
  - 更快
- 缺点
  - 可能错过全局最优解

3. **贝叶斯优化算法**

对目标函数形状进行学习，找到使目标函数向全局最优值提升的参数。

- 优点
  - 不同于前两种方法测试一个新点时会忽略前一个点的信息；贝叶斯优化算法充分利用之前的信息

- 缺点
  - 容易陷入局部最优值



- [ ] [1-12  误差分析是什么？你是如何进行误差分析？](#1-12)
- [ ] [1-13  你是如何理解模型的偏差和方差？什么样的情况是高偏差，什么情况是高方差？](#1-13)
- [ ] [1-14  出现高偏差或者高方差的时候你有什么优化策略？](#1-14)
- [ ] [1-15  奥卡姆剃刀定律是什么？对机器学习模型优化有何启发？举例说明](#1-15)

奥卡姆剃刀定律：若有多个假设与观察一致，则选最简单的那个

奥卡姆剃刀原理应用于模型选择时变为以下想法：在所有可能选择的模型中，能够很好地解释已知数据并且十分简单才是最好的，也就是应该选择的模型。

从贝叶斯估计的角度来看，正则化项对应于模型的先验概率。可以假设复杂的模型有较小的先验概率，简单的模型有较大的先验概率。



- [ ] [1-16  线性模型和非线性模型的区别？哪些模型是线性模型，哪些模型是非线性模型？](#1-16)

非概率模型可以分为线性模型和非线性模型。如果函数 $y=f(x)$ 或 $z = g(x)$ 是线性函数，则称模型是线性模型，否则成模型为非线性模型。

**线性模型**：感知机、线性支持向量机、k近邻、k均值、潜在语义分析

**非线性模型**：核函数支持向量机、AdaBoost，神经网络



- [ ] [1-17  生成式模型和判别式模型的区别？哪些模型是生成式模型，哪些模型是判别式模型？](#1-17)

监督学习方法分为生成方法（generative approach）和判别方法（discriminative approach）。所学习到的模型分别称为生成模型和判别模型。监督学习的模型一般形式为决策函数：$Y = f(X)$ 或者条件概率分布 $P(Y|X)$。

**生成方法**由数据学习联合概率分布  $P(X,Y)$，然后求出条件概率分布  $P(Y|X)$作为预测模型：
$$
P(Y|X) = \frac{P(X,Y)}{P(X)}
$$
之所以成为生成方法，是因为模型表示了给定输入 $X$ 产生输出 $Y$的生成关系。

典型的生成模型：朴素贝叶斯法、隐马尔可夫模型。

**判别方法**由数据直接学习决策函数 $f(X)$ 或者条件概率分布 $P(X,Y)$作为预测的模型，关心的是对给定的输入 $X$，应该预测什么样的输出 $Y$。

典型的判别模型：k近邻、感知机、决策树、逻辑斯蒂回归、最大熵模型、支持向量机、提升方法、条件随机场。



- [ ] [1-18 概率模型和非概率模型的区别？哪些模型是概率模型，哪些模型是非概率模型？](#1-18)

概率模型与非概率模型的区别在于模型的内在结构。**概率模型一定可以表示为联合概率分布的形式**，其中的变量表示输入、输出、因变量甚至参数。而针对非概率模型则不一定存在这样的联合概率分布。

统计学习的模型可以分为概率模型（probabilistic model）和非概率模型（non-probabilistic model）或者确定性模型（deterministic model）。在监督学习中，概率模型取条件概率分布形式 $p(y|x)$，非概率模型取函数形式 $y=f(x)$，其中$x$是输入，$y$是输出。在无监督学习中，概率模型取条件概率分布形式 $p(z|x)$或 $p(x|z)$，其中$x$是输入，$z$是输出。在监督学习中，概率模型是生成模型，非概率模型是判别模型。

**概率模型**：决策树、朴素贝叶斯、隐马尔可夫模型、条件随机场、概率潜在语义分析、潜在狄利克雷分布、高斯混合模型

**非概率模型**：感知机、支持向量机、k近邻、AdaBoost、k均值、潜在语义分析、神经网络

逻辑斯蒂回归即可看做概率模型，又可看做非概率模型。



- [ ] [1-19 参数化模型和非参数化模型的区别？哪些模型是参数化模型，哪些模型是非参数化模型？](#1-18)

统计学习模型又可以分为参数化模型（parametric model）和非参数化模型（non-parametric model）。参数化模型假设模型参数的维度固定，模型可以由有限维参数完全刻画；非参数模型假设模型参数的维度不固定或者说无穷大，随着训练数据量的增加而不断增大。

**参数化模型**：感知机、朴素贝叶斯、逻辑斯蒂回归、k均值、高斯混合模型

**非参数化模型**：决策树、支持向量机、AdaBoost、k近邻、潜在语义分析、概率潜在语义分析、潜在狄利克雷分配



## **2、经典机器学习**

### **特征工程**

- [ ] [2-1-1  你是怎样理解“特征”？](#2-1-1)
- [ ] [2-1-2  给定场景和问题，你如何设计特征？（特征工程方法论）](#2-1-2)
- [ ] [2-1-3  开发特征时候做如何做数据探索，怎样选择有用的特征？](#2-1-3)
- [ ] [2-1-4  你是如何做数据清洗的？举例说明](#2-1-4)
- [ ] [2-1-5  如何发现数据中的异常值，你是如何处理？](#2-1-5)
- [ ] [2-1-6  缺失值如何处理？](#2-1-6)

1. 缺失值较多.直接将该特征舍弃掉，否则可能反倒会带入较大的noise，对结果造成不良影响。 
2. 缺失值较少,其余的特征缺失值都在10%以内，我们可以采取很多的方式来处理:
   1. 把NaN直接作为一个特征，假设用0表示； 
   2. 用均值填充； 
   3.  用随机森林等算法预测填充



- [ ] [2-1-7  对于数值类型数据，你会怎样处理？为什么要做归一化？归一化有哪些方法？离散些方法，离散化和归一化有哪些优缺点？](#2-1-7)

**哪些机器学习算法不需要做归一化处理？**

概率模型不需要归一化，因为它们不关心变量的值，而是关心变量的分布和变量之间的条件概率，如决策树、RF。而像Adaboost、GBDT、XGBoost、SVM、LR、KNN、KMeans之类的最优化问题就需要归一化。



- [ ] [2-1-8  标准化和归一化异同？](#2-1-8)

简单来说，**标准化**是依照特征矩阵的列处理数据，其通过求z-score的方法，将样本的特征值转换到同一量纲下。归一化是依照特征矩阵的行处理数据，其目的在于样本向量在点乘运算或其他核函数计算相似性时，拥有统一的标准，也就是说都转化为“单位向量”。



- [ ] [2-1-9  你是如何处理CTR类特征？](#2-1-9)
- [ ] [2-1-10  讲解贝叶斯平滑原理？以及如何训练得到平滑参数](#2-1-10)
- [ ] [2-1-11  类别型数据你是如何处理的？比如游戏品类，地域，设备](#2-1-11)
- [ ] [2-1-12  序号编码、one-hot编码、二进制编码都是什么？适合怎样的类别型数据？](#2-1-12)
- [ ] [2-1-13  时间类型数据你的处理方法是什么？原因？](#2-1-13)
- [ ] [2-1-14  你怎样理解组合特征？举个例子，并说明它和单特征有啥区别](#2-1-14)
- [ ] [2-1-15  如何处理高维组合特征？比如用户ID和内容ID？](#2-1-15)
- [ ] [2-1-16  如何理解笛卡尔积、外积、内积？](#2-1-16)
- [ ] [2-1-17  文本数据你会如何处理？](#2-1-17)
- [ ] [2-1-18  文本特征表示有哪些模型？他们的优缺点都是什么？](#2-1-18)

**词袋模型**（Bag of Words）：每篇文章看成一袋子词，并忽略每个词出现的顺序。每篇文章可以表示成一个长向量，向量中的每一位代表一个单词，该维对应的权重则反映这个词在原文章中的重要程度，常用TF-IDF来计算权重。

缺点：无法识别出两个不同的词或者词组具有相同的主题。

**N-gram模型**：将连续出现的n个词（n<=N）组成的词组也作为一个单独的特征放到向量表示中。

缺点：无法识别出两个不同的词或者词组具有相同的主题。

**主题模型**（Topic Model）：是一种特殊的概率图模型

**词嵌入模型**（Word Embedding）：将词向量化；核心思想是将每个词映射到低维空间（K=50~300维）上的一个稠密向量。K维空间的每一维也可以看作一个隐含的主题



- [ ] [2-1-19  讲解TFF原理，它有什么优点和缺点？针对它的缺点，你有什么优化思路？](#2-1-19)

$$
{\rm TF-IDF}(t,d) = {\rm TF}(t,d) \times {\rm IDF}(t)
$$

其中 ${\rm TF}(t,d)$ 为单词t在文档d中出现的频率，${\rm IDF}(t)$ 是逆文档频率，用来衡量单词t对表达语义所起的重要性
$$
{\rm IDF}(t) = {\rm log} \frac{文章总数}{包含单词t的文章总数+1}
$$
优点：



- [ ] [2-1-20  N-gram算法是什么？有什么优缺点？](#2-1-20)
- [ ] [2-1-21  讲解一下word2vec工作原理？损失函数是什么？](#2-1-21)
- [ ] [2-1-22  讲解一下LDA模型原理和训练过程？](#2-1-22)
- [ ] [2-1-23  Word2vec和LDA两个模型有什么区别和联系？](#2-1-23)
- [ ] [2-1-24  Skin-gram和cbow有何异同？](#2-1-24)

不同点：skip-gram使用中心词预测上下文；CBOW用上下文预测中心词

相同点：都是根据word共现的频率建模word的相似度



- [ ] [2-1-25  图像数据如何处理？有哪些常用的图像特征提取方法](#2-1-25)
- [ ] [2-1-26  你是怎样做特征选择的？卡方检验、信息值（IV）、VOE都是如何计算？](#2-1-26)
- [ ] [2-1-27  计算特征之间的相关性方法有哪些？有什么优缺点](#2-1-27)



### **基础算法原理和推导**

#### **KNN**

- [ ] [2-2-1  Knn建模流程是怎样的？](#2-2-1)

（1）根据给定的距离度量，在训练集 $T$ 中找出与 $x$ 最邻近的 $k$个点，涵盖这 $k$ 个点的邻域记作 $N_k(x)$；

（2）在$N_k(x)$中根据分类决策规则（如多数表决）决定 $x$ 的类别 $y$：
$$
y=\arg \max _{c_{j}} \sum_{x_{i} \in N_{k}(x)} I\left(y_{i}=c_{j}\right), \quad i=1,2, \cdots, N_{i} \quad j=1,2, \cdots, K
$$
在上式中，$I$为指示函数，即当$y_{i}=c_{j}$时为1，否则为0



- [ ] [2-2-2  Knn优缺点是什么？](#2-2-2)

**knn优点：**

1. 理论成熟，思想简单，既可以用来做分类又可以做回归

2. KNN是一种在线技术，新数据可以直接加入数据集而不必进行重新训练

3. 可用于非线性分类（数据集不要求线性可分）

4. 和朴素贝叶斯之类的算法比，对数据没有假设，准确度高，对异常点不敏感

   

**knn缺点：**

1. 计算量大，尤其是数据集非常大的时候
2. 样本不平衡的时候，对稀有类别的预测准确率低
3. KD树，球树之类的模型建立需要大量的内存
4. k值大小的选择很重要



- [ ] [2-2-3  Knn适合什么样的场景和数据类型？](#2-2-3)

  通常最近邻分类器使用于特征与目标类之间的关系为比较复杂的数字类型，或者说二者关系难以理解，但是相似类间特征总是相似。

  数据要求归一化，统一各个特征的量纲。



- [ ] [2-2-4  常用的距离衡量公式都有哪些？具体说明它们的计算流程，以及使用场景？](#2-2-4)

  特征空间 $\mathcal X$ 是n维实数向量空间 $\mathbf{R}^n$ ，$x_i,x_j\in \mathcal{X}, x_i = (x_i^{(1)}, x_i^{(2)},\cdots x_i^{(n)}  ),  x_j = (x_j^{(1)}, x_j^{(2)}, \cdots, x_j^{(n)})$  。则 $x_i,x_j$的 $L_p$距离（闵可夫斯基距离）定义为
$$
  L_p(x_i, x_j) = (\sum_{l=1}^n |x_i^{(l)}-x_j^{(l)}|)^{\frac{1}{p}}
$$
  这里 $p \geq 1 $。

  1.**欧式距离**

  当 $p=2$时，称为欧氏距离，强调数值上的绝对误差

  是严格定义的距离，满足正定性、对称性、三角不等式
$$
  L_2(x_i, x_j) = (\sum_{l=1}^n |x_i^{(l)}-x_j^{(l)}|)^{\frac{1}{p}}
$$
  2.**曼哈顿距离**（p=1）
$$
  L_1(x_i, x_j) = \sum_{l=1}^n |x_i^{(l)}-x_j^{(l)}|
$$
  3.**切比雪夫距离**（$p = \infty$），各个坐标距离数值差的绝对值的最大值
$$
  L_{\infty}(x_i, x_j) = \mathop{\max}_{l} \  |x_i^{(l)}-x_j^{(l)}|
$$
  4.**马氏距离**

考虑各个分量（特征）之间的相关性并与各个分量的尺度无关。给定一个样本集合$X$，$X=(x_{ij})_{m\times n}$，其协方差矩阵记为$S$。样本$x_i$与样本$x_j$之间的马氏距离$d_{ij}$定义为
$$
d_{ij} = [(x_i - x_j)^TS^{-1}(x_i - x_j)]^{\frac{1}{2}}
$$
  当$S$为单位矩阵时，即样本数据的各个分量互相独立且各个分量的方差为1时，马氏距离就是欧氏距离。



5.**相关系数**（correlation coefficient）

相关系数的绝对值越接近1，表示样本越相似；越接近0，表示样本越不相似。

$x_i$与$x_j$之间的相关系数定义为
$$
r_{ij} = 
\frac{\sum_{k=1}^{m}\left(x_{k i}-\overline{x}_{i}\right)\left(x_{k j}-\overline{x}_{j}\right)}{\left[\sum_{k=1}^{m}\left(x_{k i}-\overline{x}_{i}\right)^{2} \sum_{k=1}^{m}\left(x_{k j}-\overline{x}_{j}\right)^{2}\right]^{\frac{1}{2}}}
$$

$$
\overline{x}_{i}=\frac{1}{m} \sum_{k=1}^{m} x_{k i}, \quad \overline{x}_{j}=\frac{1}{m} \sum_{k=1}^{m} x_{k j}
$$

 4.**余弦相似度**

  强调方向上的相对误差

  不是严格定义的距离，满足正定性、对称性，不满足三角不等式
$$
  cos(A,B) = \frac{A \cdot B}{||A||_2 ||B||_2}
$$
  5.**KL散度**

  计算两个分布的差异性

  不是严格定义的距离，满足正定性，不满足对称性、三角不等式



**使用场景**

欧氏距离：适用于向量各分量的度量标准统一的情况；当某些特征比其他特征取值大很多时，精确度会变差，很多特征值为0，即稀疏矩阵，结果不准，数据点的分布是某个圆心的半径，用欧式距离就不能比较了。

曼哈顿距离：适用于计算类似街区距离这样的实际问题。异常值对分类结果影响比欧式距离小。量纲不同时使用曼哈顿距离比欧式距离好。

**总结**

用距离度量相似度时，距离越小样本越相似；用相关系数时，相关系数越大样本越相似。



- [ ] [2-2-5  超参数K值过大或者过小对结果有什么影响，你是如何选择K值？](#2-2-5)

如果选择较小的K值，就相当于用较小的领域中的训练实例进行预测，“学习”近似误差会减小，只有与输入实例较近或相似的训练实例才会对预测结果起作用，与此同时带来的问题是“学习”的估计误差会增大，换句话说，K值的减小就意味着整体模型变得复杂，容易发生过拟合；

如果选择较大的K值，就相当于用较大领域中的训练实例进行预测，其优点是可以减少学习的估计误差，但缺点是学习的近似误差会增大。这时候，与输入实例较远（不相似的）训练实例也会对预测器作用，使预测发生错误，且K值的增大就意味着整体的模型变得简单。

K=N，则完全不足取，因为此时无论输入实例是什么，都只是简单的预测它属于在训练实例中最多的累，模型过于简单，忽略了训练实例中大量有用信息。

在实际应用中，K值一般取一个比较小的数值，例如采用交叉验证法（简单来说，就是一部分样本做训练集，一部分做测试集）来选择最优的K值。



- [ ] [2-2-6  介绍一下Kd树？如何建树，以及如何搜索最近节点？](#2-2-6)

  kd树是一种对k维空间中的实例点进行存储，以便对其进行快速检索的树形数据结构。kd树是二叉树，表示对k维空间的一个划分。构造kd树相当于不断地用垂直于坐标轴的超平面将k维空间切分，构成一系列的k维超矩形区域。kd树的每个节点对应于一个k维超矩形区域。
  
  **构造平衡kd树过程：**
  
  输入：k维空间数据集 $T=\left\{x_{1}, x_{2}, \cdots, x_{N}\right\}$，其中$x_{i}=\left(x_{i}^{(1)}, x_{i}^{(2)}, \cdots, x_{i}^{(k)}\right)^{\mathrm{T}}, \quad i=1,2, \cdots, N_{\mathrm{i}}$
  
  输出：kd树
  
  （1）开始：构造根节点，根节点对应于包含T的k维空间的超矩形区域
  
  ​	选择 $x^{(1)} $ 为坐标轴，以T中所有实例的 $x^{(1)} $ 坐标的中位数为切分点，将根节点对应的超矩形区域且分为两个子区域。切分由通过切分点并与坐标轴 $x^{(1)}$垂直的超平面实现。
  
  ​	由根节点生成深度为1的左、右子节点：左子节点对应坐标 $x^{(1)}$小于切分点的子区域，右子节点对应于坐标 $x^{(1)}$ 大于切分点的子区域。
  
  ​	将落在切分超平面上的实例点保存在根节点。
  
  （2）重复：对深度为$j$ 的节点，选择 $x^{(l)}$ 为切分的坐标轴，$l = j({\rm mod}\ k) + 1$，以该节点的区域中所有实例的 $x^{(l)}$ 坐标的中位数为切分点，将该节点对应的超矩形区域切分为两个子区域。切分由通过切分点并与坐标轴 $x^{(l)}$垂直的超平面实现。
  
  ​	由该节点生成深度为 $j+1$ 的左、右子节点：左子节点对应坐标 $x^{(l)}$小于切分点的子区域，右子节点对应坐标$x^{(l)}$大于切分点的子区域。
  
  ​	将落在切分超平面上的实例点保存在根节点。
  
  （3）直到两个子区域没有实例存在时停止，从而形成kd树的区域划分
  
  ![](https://raw.githubusercontent.com/zhengjingwei/image-bed/master/kdtree-1.jpg)
  
  ![](https://raw.githubusercontent.com/zhengjingwei/image-bed/master/kdtree-2.jpg)
  
  
  
  **算法：用kd树的最近邻搜索**
  
  输入：已构造的kd树：目标点$x$；
  
  输出：$x$的最近邻
  
  （1）在kd树中找出包含目标点$x$的叶节点：从根节点出发，递归地向下访问kd树。若目标点$x$当前维的坐标小于切分点的坐标，则移动到左子节点，否则移动到右子节点。直到子节点为叶节点为止。
  
  （2）以此叶节点为“当前最近点”。
  
  （3）递归地向上回退，在每个节点进行以下操作：
  
  ​		（a）如果该节点保存的实例点比当前最近点距离目标点更近，则以该实例点作为“当前最近点”
  
  ​		（b）当前最近点一定存在于该节点一个子节点对应的区域。检查该子节点的父节点的另一子节点（兄弟节点）对应区域是否有更近的点。具体地，检查另一子节点对应的区域是否与以目标点为球心、以目标点与“当前最近点”间的距离为半径的超球体相交。
  
  ​		如果相交，可能在另一个子节点对应的区域内存在距目标点更近的点，移动到另一个子节点。接着递归地进行最近邻搜索；
  
  ​		如果不相交，向上回退
  
  （4）当回退到根节点时，搜索结束。最后的“当前最近点”即为$x$的最近邻点。
  
  
  
  如果实例点是随机分布的，kd树搜索的平均计算复杂度是 $O({\rm log} N)$，这里 $N$ 是训练实例数。**kd树更适用与训练实例数远大于空间维数时的k近邻搜索。**当空间维数接近训练实例数时，它的效率会迅速下降，几乎接近线性扫描。
  
  ![](https://raw.githubusercontent.com/zhengjingwei/image-bed/master/kdtree-3.jpg)
  
  
  
  
  
  

#### **支持向量机**

hinge loss + kernel method

- [ ] [2-3-1  简单讲解SVM模型原理？](#2-3-1)

  支持向量机是是一种二类分类模型，它的基本模型是是定义在特征空间的**间隔最大的线性分类器**，间隔最大，间隔最大使它有别于感知机；支持向量机还包括**核技巧**，这使它成为实质上的非线性分类器。支持向量机的学习策略是**间隔最大化**，可形式化为求解凸二次规划的问题，也**等价于正则化的合页损失函数最小化问题**。

  线性可分支持向量机：当训练数据线性可分，通过硬间隔最大化，学习一个线性的分类器

  线性支持向量机：当训练数据近似线性可分，通过软间隔最大化，学习一个线性的分类器

  非线性支持向量机：当训练数据线性不可分，通过使用核技巧及软间隔最大化，学习非线性分类器

  

- [ ] [2-3-2  SVM为什么会对缺失值敏感？实际应用时候你是如何处理？](#2-3-2)

  涉及到距离度量(distance measurement)时，如计算两个点之间的距离，缺失数据就变得比较重要。如果缺失值处理不当就会导致效果很差，如SVM，KNN。

  常用的缺失值处理方法：

  （1）把数值型变量(numerical variables)中的缺失值用其所对应的类别中(class)的中位数(median)替换。把描述型变量(categorical variables)缺失的部分用所对应类别中出现最多的数值替代(most frequent non-missing value)。【快速简单但效果差】（平均数、中位数、众数、插值等）

  （2）将缺失值当成新的数值，NaN

  （3）忽略该项数据（当缺失少时）

  

- [ ] [2-3-3  SVM为什么可以分类非线性问题？](#2-3-3)

  原输入空间是一个非线性可分问题，能用一个超曲面将正负例正确分开；

  通过核技巧的非线性映射，将输入空间的超曲面转化为特征空间的超平面，原空间的非线性可分问题就变成了新空间的的线性可分问题。低维映射到高维。

  在核函数 $K(x,z)$ 给定的条件下，可以利用解线性分类问题的方法求解非线性分类问题的支持向量机。学习是隐式地在特征空间进行的，在学习和预测中只定义核函数 $K(x,z)$，而不需要显式地定义特征空间和映射函数$\phi$，这样的技巧成为核技巧。通常直接计算$K(x,z)$比较容易，而通过$\phi(x)$和$\phi(z)$计算$K(x,z)$并不容易。

  对于给定核 $K(x,z)$，特征空间和映射函数的取法并不唯一。

  

- [ ] [2-3-4  常用的核函数有哪些？你是如何选择不同的核函数的？](#2-3-4)

  **核函数定义**：设$\mathcal{X}$是输入空间，又设$\mathcal{H}$为特征空间，如果存在一个从$\mathcal{X}$到$\mathcal{H}$的映射
  $$
  \phi(x) : \mathcal{X} \rightarrow \mathcal{H}
  $$
  使得对所有$x, z \in \mathcal{X}$，函数$K(x, z)$满足条件
  $$
  K(x, z)=\phi(x) \cdot \phi(z)
  $$
  则称$K(x, z)$为核函数，$\phi(x)$为映射函数，式中$\phi(x) \cdot \phi(z)$$为\phi(x)$和$\phi(z)$的内积 

  **线性核函数**
  $$
  K(x,z) = x\cdot z
  $$
  主要用于线性可分的情况。可以看到特征空间到输入空间的维度是一样的，其参数少速度快，对于线性可分数据，其分类效果很理想，因此我们通常首先尝试用线性核函数来做分类，看看效果如何，如果不行再换别的。

  

  **多项式核函数**（polynomial kernel function）
  $$
  K(x, z)=(x \cdot z+1)^{p}
  $$
  对应的支持向量机是一个p次多项式分类器。分类决策函数为
  $$
  f(x)=\operatorname{sign}\left(\sum_{i=1}^{N_{s}} a_{i}^{*} y_{i}\left(x_{i} \cdot x+1\right)^{p}+b^{*}\right)
  $$
  多项式核函数可以实现将低维的输入空间映射到高维的特征空间，但是多项式核函数的参数多，当多项式的阶数比较高的时候，核矩阵的元素值将趋于无穷大或者无穷小，计算复杂度会大到无法计算。

  

  **高斯核函数**（Gaussian kernel function） 
  $$
  K(x,z) = exp(-\frac{1}{2} \ ||x - z ||_2 ) = \phi(x) \cdot \phi(z)
  $$
  对应的支持向量机是高斯径向基函数（radial basis function）分类器，分类决策函数为
  $$
  f(x)=\operatorname{sign}\left(\sum_{i=1}^{N_{s}} a_{i}^{*} y_{i} \exp \left(-\frac{\|x-x_i\|^{2}}{2 \sigma^{2}}\right)+b^{*}\right)
  $$
  高斯径向基函数是一种局部性强的核函数，其可以将一个样本映射到一个更高维的空间内，该核函数是应用最广的一个，无论大样本还是小样本都有比较好的性能，而且其相对于多项式核函数参数要少，因此大多数情况下在不知道用什么核函数的时候，优先使用高斯核函数。

  

  **Sigmod核函数**
  $$
  K\left(x, z\right)=\tanh \left(\eta \ x \cdot z +\theta\right)
  $$
  总结

  - 如果特征的数量大到和样本数量差不多，则选用LR或者线性核的SVM；
    - （特征维度高，往往线性可分，SVM解决非线性分类问题的思路就是将样本映射到更高维的特征空间中）
  - 如果样本数量很多，由于求解最优化问题的时候，目标函数涉及两两样本计算内积，使用高斯核明显计算量会大于线性核，所以手动添加一些特征，使得线性可分，然后可以用LR或者线性核的SVM
  - 如果特征的数量小，样本的数量正常，则选用SVM+高斯核函数；

  

- [ ] [2-3-5  RBF核函数一定线性可分么？为什么](#2-3-5)

  根据Cover定理，从低维度映射到高维度后，线性可分的可能性比较大。

  而RBF核函数将原始空间映射到无穷维的特征空间，基本线性可分（也有线性不可分的情况，如加入噪声：同一样本不同标签）。如果忽略噪声，同时允许一定限度的误差，可以说升到足够高的维度，几乎所有数据集都是线性可分了。

  同时，维度特别高，几乎一定线性可分，也以为这模型特别复杂，几乎一定会碰到过拟合问题。

  

- [ ] [2-3-6  SVM属于线性模型还是非线性模型？为什么？](#2-3-6)

  基本模型是一个线性分类器；而通过使用核函数可以学习非线性支持向量机

  

- [ ] [2-3-7  训练误差为0的SVM分类器一定存在吗？说明原因？](#2-3-7)

  对于训练一个不加入松弛变量的SVM模型时，一定存在。百面p55

  对于加入松弛变量的SVM的训练误差不一定能达到0

  

- [ ] [2-3-8  当用支持向量机进行分类时，支持向量越多越好还是越少越好](#2-3-7)

  结论：在n维特征空间中，线性SVM一般会产生n+1个支持向量（不考虑退化情况） 

  通常的SVM的使用会伴随着核技巧（kernel），这用于将低维空间映射到一个更高维的空间，使得原本不线性可分的数据点变得在高维空间中线性可分。虽然这种映射是隐式的，我们通常并不知道映射到的空间是什么样子。但是根据之前的结论，我们可以认为如果训练出来的SVM有d+1个支持向量，这个kernel在这个任务里就讲原来的数据映射到了一个d维的空间中，并使得其线性可分。

  更高的维度通常意味着更高的模型复杂度，所以支持向量越多，表示着训练得到的模型越复杂。根据泛化理论，这意味着更有过拟合的风险。

   如果在性能一致的情况下，更少的支持向量可能是更好的。但是这一点其实不绝对，因为泛化理论仅仅是误差的上界，实际的泛化情况的决定因素比较复杂，也可能取决于kernel的性质。所以还是自己做cross validation比较好。

  

#### **朴素贝叶斯模型**

- [ ] [2-4-1  讲解贝叶斯定理？](2-4-1)
  $$
  P\left(B_{i} | A\right)=\frac{P\left(B_{i}\right) P\left(A | B_{i}\right)}{\sum_{j=1}^{n} P\left(B_{j}\right) P\left(A | B_{j}\right)}
  $$

- [ ] [2-4-2  什么是条件概率、边缘概率、联合概率？](#2-4-2)

  **条件概率**：条件概率表示在条件$Y=b$成立的情况下，$X=a$的概率，记作$P(X=a|Y=b)$或$P(a|b)$。它具有如下性质： “在条件Y=b下X的条件分布”也是一种“X的概率分布”，因此穷举X的可取值之后，所有这些值对应的概率之和为1 即： 
  $$
  \sum_{a} P(X=a | Y=b)=1
  $$
  **边缘概率**：仅与单个随机变量有关的概率称为边缘概率，如 $P(X=a)$ 或 $P(Y=b)$

  **联合概率**：联合概率指的是包含多个条件且**所有条件同时成立**的概率，记作$P(X=a,Y=b)$或$P(a,b)$

  联合概率、边缘概率与条件概率的关系：
  $$
  P(X=a | Y=b)=\frac{P(X=a, Y=b)}{P(Y=b)}
  $$
  
- [ ] [2-4-3  后验概率最大化的含义是什么？](#2-4-3)

  朴素贝叶斯法将实例分到后验概率最大的类中。后验概率最大化这等价于期望风险最小化。

  假设选择0-1损失函数：
  $$
  L(Y, f(X))=\left\{\begin{array}{ll}{1,} & {Y \neq f(X)} \\ {0,} & {Y=f(X)}\end{array}\right.
  $$
  其中 $f(X)$是分类决策函数。这是期望风险函数为
  $$
  R_{\operatorname{cap}}(f)=E[L(Y, f(X))]
  $$
  期望是对联合分布 $P(X,Y)$ 取的。由此取条件期望
  $$
  R_{\mathrm{exp}}(f)=E_{X} \sum_{k=1}^{K}\left[L\left(c_{k}, f(X)\right)\right] P\left(c_{k} | X\right)
  $$
  为了使期望奉献最小化，只需对 $X=x$ 逐个最小化，由此得到
  $$
  \begin{aligned} f(x) &=\arg \min _{y \in \mathcal{Y}} \sum_{k=1}^{K} L\left(c_{k}, y\right) P\left(c_{k} | X=x\right) \\ &=\arg \min _{y \in \mathcal{Y}} \sum_{k=1}^{K} P\left(y \neq c_{k} | X=x\right) \\ &=\arg \min _{y \in \mathcal{Y}}\left(1-P\left(y=c_{k} | X=x\right)\right) \\ &=\arg \max _{y \in \mathcal{Y}} P\left(y=c_{k} | X=x\right) \end{aligned}
  $$
  这样一来，根据期望风险最小化准则就得到了后延概率最大化准则：
  $$
  f(x)=\arg \max _{c_{k}} P\left(c_{k} | X=x\right)
  $$
  即朴素贝叶斯法所采用原理

  

- [ ] [2-4-4  朴素贝叶斯模型如何学习的？训练过程是怎样？](#2-4-4)

  对于给定的训练数据集，首先基于特征条件独立性假设学习输入输出的联合概率分布；

  然后基于此模型，对给定的输入x，利用贝叶斯定理求出后验概率最大的输出y。

  **训练过程**：

  （1）计算先验概率及条件概率
  $$
  \begin{array}{l}{P\left(Y=c_{k}\right)=\frac{\sum_{i=1}^{N} I\left(y_{i}=c_{k}\right)}{N}, \quad k=1,2, \cdots, K} \\ {P\left(X^{(j)}=a_{j l} | Y=c_{k}\right)=\frac{\sum_{i=1}^{N} I\left(x_{i}^{(j)}=a_{j}, y_{i}=c_{k}\right)}{\sum_{i=1}^{N} I\left(y_{i}=c_{k}\right)}} \\ {j=1,2, \cdots, n ; \quad l=1,2, \cdots, S_{j} ; \quad k=1,2, \cdots, K}\end{array}
  $$
  （2）对于给定实例 $x=\left(x^{(1)}, x^{(2)}, \cdots, x^{(n)}\right)^{\mathrm{T}}$，计算
  $$
  P\left(Y=c_{k}\right) \prod_{i=1}^{n} P\left(X^{(j)}=x^{(j)} | Y=c_{k}\right), \quad k=1,2, \cdots, K
  $$
  （3）确定实例x的类（最大后验概率）
  $$
  y = \arg\max_{c_k}\ P(Y=c_k)\prod_{j}P(X^{(j)}=x^{(j)}|Y=c_k)
  $$
  
- [ ] [2-4-5  你如何理解生成模型和判别模型？](#2-4-5)

  **生成方法**由数据学习联合概率分布  $P(X,Y)$，然后求出条件概率分布  $P(Y|X)$作为预测模型：
  $$
  P(Y|X) = \frac{P(X,Y)}{P(X)}
  $$
  之所以成为生成方法，是因为模型表示了给定输入 $X$ 产生输出 $Y$的生成关系。

  典型的生成模型：朴素贝叶斯法、隐马尔可夫模型。

  **判别方法**由数据直接学习决策函数 $f(X)$ 或者条件概率分布 $P(X,Y)$作为预测的模型，关心的是对给定的输入 $X$，应该预测什么样的输出 $Y$。

  典型的判别模型：k近邻、感知机、决策树、逻辑斯蒂回归、最大熵模型、支持向量机、提升方法、条件随机场。

  

- [ ] [2-4-6  朴素贝叶斯模型“朴素”体现在哪里？存在什么问题？有哪些优化方向？](#2-4-6)

  "朴素"体现在朴素贝叶斯模型对条件概率分布作了**条件独立性假设**，这是一个较强的假设。
  $$
  \begin{aligned} P(X&=x | Y=c_{k} )=P\left(X^{(1)}=x^{(1)}, \cdots, X^{(n)}=x^{(n)} | Y=c_{k}\right) \\ &=\prod_{j=1}^{n} P\left(X^{(j)}=x^{(j)} | Y=c_{k}\right) \end{aligned}
  $$
  存在问题：当特征分布不满足条件独立性假设时，分类的性能不高

  优化方法：贝叶斯网络

  

- [ ] [2-4-7  什么是贝叶斯网络？它能解决什么问题？](#2-4-7)

  朴素贝叶斯法假设输入变量都是条件独立的，如果假设他们之间**存在概率依存关系**，模型就被成了贝叶斯网络。

  贝叶斯网络也称为“信念网”，借助**有向无环图**来刻画属性之间的依赖关系，并使用**条件概率表**来描述属性的联合概率分布。贝叶斯网结构有效地表达了属性的条件独立性。

  具体来说，一个贝叶斯网B由结构G和参数 $\theta$ 表示，即 $B = <G,\theta>$ 。网络结构G是一个邮箱无环图，其每个节点对应于一个属性，若两个属性有直接依赖关系，则它们由一条边连接起来；参数 $\theta$ 定量描述这种依赖关系，假设属性 $x_i$ 在G中的父节点集为 $\pi_i$，则 $\theta$包含了每个属性的条件概率 $\theta_{x_i|\pi_i} = P_B(x_i|\pi_i)$。

  

  给定父节点集，贝叶斯网假设每个属性与它的非后裔属性独立，于是将属性的联合概率分布定义为

$$
P_{B}\left(x_{1}, x_{2}, \ldots, x_{d}\right)=\prod_{i=1}^{d} P_{B}\left(x_{i} | \pi_{i}\right)=\prod_{i=1}^{d} \theta_{x_{i} | \pi_{i}}以上图为例，联合概率分布定义为
$$

​		
$$
P\left(x_{1}, x_{2}, x_{3}, x_{4}, x_{5}\right)=P\left(x_{1}\right) P\left(x_{2}\right) P\left(x_{3} | x_{1}\right) P\left(x_{4} | x_{1}, x_{2}\right) P\left(x_{5} | x_{2}\right)
$$
​		**贝叶斯网学习过程**

​		精确求解NP难，所以（1）贪心法：从某个网络结构出发，每次调整一条边，直到评分函数值不再降低（2）给网络结构施加约束条件：如限定为树形结构等。

​		**贝叶斯网推断**

​		理想情况根据贝叶斯网定义的联合概率分布来精确计算后验概率，但这样的精确推断时NP难的。近似推断采用吉布斯采样法，通过随机游走，使马尔可夫链趋于平稳分布。



- [ ] [2-4-8  为什么说朴素贝叶斯也是线性模型而不是非线性模型呢？](#2-4-8)

  线性分类器是通过特征的线性组合来做出分类决定的分类器。本质上，朴素贝叶斯分类器是一种线性分类器。
  
  朴素贝叶斯分类器是建立在属性变量相互独立的基础上，后验概率为判定准则的分类器。不等式1成立，则样例x=[x_1,...,x_n]为正类。否则，样例为负类。
  
   (1) 
  
  ![img](https:////upload-images.jianshu.io/upload_images/1385318-0c8849c769c7cae3?imageMogr2/auto-orient/strip%7CimageView2/2/w/291/format/webp)
  
  线性分类器直观地来说，是在高维样本空间中找到一组超平面，将样本空间划分了两个区域。每个区域对应于不同的类别。数学上来说，线性分类器能找到权值向量w，使得判别公式可以写成特征值的线性加权组合。
  
   (2) 
  
  ![img](https:////upload-images.jianshu.io/upload_images/1385318-2443a8f4fea70ee7?imageMogr2/auto-orient/strip%7CimageView2/2/w/137/format/webp)
  
  如果公式2成立，则样本属于正类；反之，则样本属于负类。
  
  ------
  
  **离散特征的朴素贝叶斯分类器**
  
  一般离散特征的取值范围有两种，{-1,1}或者{0,1}。这两种取值方式不会影响分析。不妨假设离散特征的取值范围为{-1,1}。下面的不等式成立，样例x=[x_1,...,x_n]为正类。
   (3)
  
  ![img](https:////upload-images.jianshu.io/upload_images/1385318-fbf05fdf34f5fdd5?imageMogr2/auto-orient/strip%7CimageView2/2/w/385/format/webp)
  
  
  
  对于某个特征x，我们很容易推导出下面的公式
  
   (4)
  
  ![img](https:////upload-images.jianshu.io/upload_images/1385318-f7280559286d0abc?imageMogr2/auto-orient/strip%7CimageView2/2/w/526/format/webp)
  
  
  
  其中p(x|F)也有类似的结果，从而有
   (5)
  
  
  
  ![img](https:////upload-images.jianshu.io/upload_images/1385318-101318b723db87f3?imageMogr2/auto-orient/strip%7CimageView2/2/w/490/format/webp)
  
  将公式5带入朴素贝叶斯分类器的公式3，得到下面的公式
   (6)
  
  ![img](https:////upload-images.jianshu.io/upload_images/1385318-d3e418e1bef50305?imageMogr2/auto-orient/strip%7CimageView2/2/w/529/format/webp)
  
  根据公式6，离散特征的朴素贝叶斯分类器判别公式能够写成特征值的加权线性组合。也就是说，离散特征的朴素贝叶斯分类器本质上是线性分类器。
  
  
  
- [ ] [2-4-9  如何解决用极大似然法可能出现所要估计的概率为0的情况？](#2-4-9)

  分子加1，分母加可能情况数

  用极大似然法估计可能会出现所要估计的概率值为0的情况。这是会影响到后验概率的计算结果，使分类产生偏差。解决这一问题的方法是采用贝叶斯估计。具体地，条件概率的贝叶斯估计是
  $$
  P_{\lambda}\left(X^{(j)}=a_{j l} | Y=c_{k}\right)=\frac{\sum_{i=1}^{N} I\left(x_{i}^{(j)}=a_{j l}, y_{i}=c_{k}\right)+\lambda}{\sum_{i=1}^{N} I\left(y_{i}=c_{k}\right)+S_{j} \lambda}
  $$
  式中 $\lambda \geq 0$。等价于在随机变量各个取值的频数上赋予一个正数 $\lambda$。当$\lambda=0$时就是极大似然估计。常取 $\lambda=1$，这时称为拉普拉斯平滑（laplacian smoothing）。显然，对任何$l=1,2, \cdots, S_{j}, \quad k=1,2, \cdots, K$ 有
  $$
  \begin{array}{l}{P_{\lambda}\left(X^{(j)}=a_{j l} | Y=c_{k}\right)>0} \\ {\sum_{l=1}^{s_{j}} P\left(X^{(j)}=a_{j l} | Y=c_{k}\right)=1}\end{array}
  $$

  表明上式确实为一种概率分布。同样，先验概率的贝叶斯估计是
  $$
  P_{\lambda}\left(Y=c_{k}\right)=\frac{\sum_{i=1}^{N} I\left(y_{i}=c_{k}\right)+\lambda}{N+K \lambda}
  $$



#### **线性回归**

- [ ] [2-5-1  线性回归的基本思想是？](#2-5-1)
- [ ] [2-5-2  什么是“广义线性模型”？](#2-5-2)
- [ ] [2-5-3  线性回归常用的损失函数有哪些？优化算法有哪些？](#2-5-3)
- [ ] [2-5-4  线性回归适用什么类型的问题？有哪些优缺点？](#2-5-4)
- [ ] [2-5-5  请用最小二乘法推倒参数更新公式？](#2-5-5)



#### **逻辑回归**

- [ ] [2-6-1  逻辑回归相比于线性回归有什么异同？](#2-6-1)

**不同点**：

- 逻辑回归处理的是分类问题，线性回归处理的是回归问题；
- 逻辑回归中认为y是因变量，即逻辑回归的因变量是离散的，线性回归的因变量是连续的。



**相同点：**

- 二者都使用了极大似然估计来对训练样本进行建模
- 求解超参数过程中，都可以使用梯度下降的方法



**联系**：

如果把一个事件的几率（odds）定义为该事件发生的概率与不发生概率的比值 $\frac{p}{1-p}$ ，那么逻辑回归可以看做是对于"y=1|x"这一事件的对数几率的线性回归
$$
{\rm log} \frac{p}{1-p} = \theta^{T}x ，其中\ p  = P(y=1|x)
$$


- [ ] [2-6-2  逻辑回归和广义线性模型有何关系？](#2-6-2)

可以看做广义线性模型在因变量y服从二元分布时的一个特殊情况


- [ ] [2-6-3  逻辑回归如何处理多标签分类？](#2-6-3)

如果一个样本只对应于一个标签（多分类问题）：
假设每个样本属于不同标签的概率服从几何分布，使用softmax regression进行分类：
$$
h_\theta =
 \left[
 \begin{matrix}
   p(y=1|x;\theta)\\
   p(y=2|x;\theta) \\
   \vdots \\
   p(y=k|x;\theta)
  \end{matrix}
  \right] 
  = 
  \frac{1}{\sum_{j=1}^{k} e^{\theta^T x}}
  
  \left[
 \begin{matrix}
   e^{\theta_1^T x}\\
   e^{\theta_2^T x} \\
   \vdots \\
   e^{\theta_k^T x}
  \end{matrix}
  \right] 
  
  \tag{3}
$$
其中 $\theta_1,\theta_2 \dots,\theta_k \in \mathbb{R}^n$

如果存在样本可能属于多个标签的情况时，可以训练k个二分类的逻辑回归分类器。第i个分类器用以区分每个样本是否可以归为第i类。



- [ ] [2-6-4  为什么逻辑回归需要进行归一化或者取对数？](#2-6-4)

- [ ] [2-6-5  为什么逻辑回归把特征离散化之后效果会提升？](#2-6-5)

- [ ] [2-6-6  类别不平衡问题你是如何处理的？什么是过采样，什么是欠采样？举例](#2-6-6)

- [ ] [2-6-7  讲解L1和L2正则，它们都有什么作用，解释为什么L1比L2更容易产生稀疏解；对于存在线性相关的一组特征，L1正则如何选择特征？](#2-6-7)

L1和L2正则，都可以防止过拟合，增强模型的泛化能力；区别在于L1使参数更稀疏，达到特征选取的作用；L2使参数更接近于0

**从解空间的形状来看：**

L1正则项约束后的解空间是多边形，而L2正则项约束后的解空间是圆形。而多边形的解空间更容易在尖角处与等高线碰撞出稀疏解。

对于存在线性相关的一组特征，L1正则会使得部分参数为0

**从函数叠加的观点：**



- [ ] [2-6-8  使用交叉熵作为损失函数，梯度下降作为优化方法，推倒参数更新公式](#2-6-8)



- [ ] [2-6-9  代码写出训练函数](#2-6-9)



#### **FM模型**

- [ ] [2-7-1  FM模型与逻辑回归相比有什么优缺点？](#2-7-1)
- [ ] [2-7-2  为什么FM模型计算复杂度时O(kn)？](#2-7-2)
- [ ] [2-7-3  介绍FFM场感知分解机器（Field-aware Factorization Machine），说说与FM异同？](#2-7-3)
- [ ] [2-7-4  使用FM进行模型训练时候，有哪些核心参数对模型效果影响大？](#2-7-4)
- [ ] [2-7-5  如何从神经网络的视角看待FM模型？](#2-7-5)



#### **决策树**

- [x] [2-8-1  讲解完成的决策树的建树过程](#2-8-1)

自上而下，对样本数据进行树形分类的过程。每个内部节点表示一个特征，叶节点表示一个类别。从顶部根节点开始，所有的样本聚在一起。经过根节点的划分，样本被分到不同的子节点，再根据子节点的特征进一步划分，直至所有样本被归到某一个类别（叶节点）中。



- [x] [2-8-2  你是如何理解熵？从数学原理上解释熵公式可以作为信息不确定性的度量？](#2-8-2)

熵（entropy）是表示随机变量不确定性的度量， $X$ 是一个取有限个值的离散随机变量，其概率分布为
$$
P(X = x_i) = p_i, \ i=1,2,\cdots,n
$$
则随机变量 $X$ 的熵定义为
$$
H(X) = -\sum_{i=1}^{n} p_i {\rm log } \ p_i
$$
熵越大，随机变量的不确定性就越大。



而熵其实表示的是一个系统的平均信息量。**自信息量**是用来描述某一条信息的大小
$$
I = - {\rm log} \ p_i
$$
通常以2为底，单位是bit；含义是用多少位二进制可以表示衡量该信息的大小。而通常我们衡量整个系统的信息量，系统存在多个事件 $X=\{x_1,\cdots,x_n\}$ ，每个事件的概率分布$P=\{p_1,\cdots,p_n\}$ ，**熵是整个系统的平均信息量** 。



- [ ] [2-8-3  联合熵、条件熵、KL散度、信息增益、信息增益比、gini系数都是什么？如何计算？](#2-8-3)

**联合熵**：将一维随机变量分布推广到多维随机变量分布
$$
H(X,Y) = -\sum\limits_{x,y} p(x,y)\ {\rm log}\ p(x,y)
$$
**条件熵**：某个特征A对于数据集D的经验条件熵 $H(D|A)$ 为
$$
H(D|A) = - \sum_{i=1}^{n} \frac{|D_i|}{|D|} H(D_i) \\ = - \sum_{i=1}^{n} \frac{|D_i|}{|D|} \lgroup \sum_{k=1}^{K} \frac{|D_{ik}|}{|D_i|} {\rm log } \frac{|D_{ik}|}{|D_i|} \rgroup
$$
**信息增益**： $g(D,A)$ 定义为数据集D的经验熵 $H(D)$ 与特征A给定条件下D的经验条件熵 $H(D|A)$ 的差
$$
g(D,A) = H(D) - H(D|A)
$$

**信息增益比**：特征A对于数据集D 的信息增益比定义为
$$
g_R(D|A) = \frac{g(D|A)}{H_A(D)}
$$
其中 
$$
H_A{(D)} = - \sum_{i=1}^{n} \frac{|D_i|}{|D|} {\rm log } \frac{|D_i|}{|D|}
$$
为数据集D关于A的取值熵；n为特征A在D上的取值数目；



**Gini系数**：描述数据的不确定性。数据集D的Gini系数为
$$
{\rm Gini}(D) = 1 - \sum_{k=1}^{K
}(\frac{|C_k|}{|D|})^2
$$
其中 $C_k$是 D中第k类的样本子集，K是类的个数。例如二分类问题，K=2。基尼系数越大，样本集合的不确定性也就越大，这一点与熵相似。基尼系数Gini(D,A)表示经A=a分割后集合D的不确定性。



**KL散度/交叉熵**

交叉熵：刻画两个概率分布之间的距离，通过q来表示p的交叉熵为；一般p(x)为真实分布，q(x)为预测分布

交叉熵不对称。交叉熵越小，概率分布越接近
$$
H(p,q) = - \sum\limits_{x} p(x) {\rm log } \ q(x)
$$
KL散度：
$$
D_{KL}(p||q) = H(p,q) - H(p)
$$


- [x] [2-8-4  常用的决策树有哪些？ID3、C4.5、CART有啥异同？](#2-8-4)

| 不同点   | ID3                  | C4.5               | CART                   |
| -------- | -------------------- | ------------------ | ---------------------- |
| 原则     | 信息增益最大         | 信息增益比最大     | 划分后集合基尼指数最小 |
| 用途     | 分类                 | 分类               | 分类、回归             |
| 输入取值 | 离散                 | 离散、连续         | 离散、连续             |
| 树结构   | 多叉树               | 多叉树             | 二叉树                 |
|          | 特征在层级间不复用   | 特征在层级间不复用 | 每个特征可被重复利用   |
|          | 对样本特征缺失值敏感 |                    |                        |



**ID3	最大信息增益**

信息增益 $g(D,A)$ 定义为数据集D的经验熵 $H(D)$ 与特征A给定条件下D的经验条件熵 $H(D|A)$ 的差
$$
g(D,A) = H(D) - H(D|A)
$$
选择 $g(D,A)$  最大的特征，所有样本根据此特征，划分到不同的节点上。在经验熵不为0的节点中继续生长。ID3算法只有树的生成，容易产生过拟合。



**C4.5	最大信息增益比**

因为信息增益对取值数目多的属性有所偏好，为了减少这种偏好带来的影响，使用信息增益比来选择最优划分属性。



**CART	基尼指数**

基尼系数Gini（D）用来表示集合D的不确定性。CART在每一次迭代中选择划分后**基尼指数最小**的特征及其对应的切分点进行分类。CART是一颗二叉树，每次将数据按特征A的区分分成两份，分别进入左右子树。



- [ ] [2-8-5  决策树如何防止过拟合？前剪枝和后剪枝过程是怎样的？剪枝条件都是什么](#2-8-5)

通过**剪枝**防止过拟合。

**预剪枝**是指在决策树生成的过程中，对每个节点在划分前先进行估计，若当前节点的划分不能带来决策树泛化性能提升，则停止划分，并将当前节点标记为叶子节点；此时可能存在不同类别的样本同时存于同个节点中，按照多数投票的原则判断节点所属类别

预剪枝对于何时停止决策树的生长：

（1）当树达到一定深度

（2）当到达当前节点的样本数量小于某个阈值

（3）计算每次分裂对测试集的准确度提升，小于某个阈值时停止



**后剪枝**则是先从训练集生成一棵完整的决策树，然后自底向上地对**非叶子节点**进行考察，若该节点对应的**子树替换成叶子结点**能带来泛化性能提升，则将该子树替换为叶子节点。





#### **随机森林（RF）**

- [ ] [2-9-1  介绍RF原理和思想](#2-9-1)
- [ ] [2-9-2  RF是如何处理缺失值？](#2-9-2)
- [ ] [2-9-3  RF如何衡量特征重要度？](#2-9-3)
- [ ] [2-9-4  RF“随机”主要体现在哪里？](#2-9-4)
- [ ] [2-9-5  RF有哪些优点和局限性？](#2-9-5)
- [ ] [2-9-6  为什么多个弱分类器组合效果会比单个要好？如何组合弱分类器可以获得更好的结果？原因是什么？](#2-9-6)
- [ ] [2-9-7  Bagging的思想是什么？它是降低偏差还是方差，为什么？](#2-9-7)

Bagging的思想是通过对数据再抽样，然后在每组样本上训练出来的模型取平均。Bagging是降低方差，防止过拟合。可以这样理解，对n个独立不相关的模型的预测结果取平均，方差是原来单个模型的 $1/n$ 。



- [ ] [2-9-8  可否将RF的基分类模型由决策树改成线性模型或者knn？为什么？](#2-9-8)

随机森林属于bagging类的集成学习方法，主要好处是减小集成后分类器的方差，比基分类器的方差小。所以Bagging所采用的的基分类器最好是本身对样本分布较为敏感（不稳定分类器），这样bagging才能体现效果。而线性分类器和KNN属于较为稳定的分类器，本身方差不大，所以将他们作为基分类器使用bagging不能再原基分类器的基础上获得更好的表现。相反地，可能因为bagging的采样而使得训练中难以收敛从而增大集成分类器的偏差。



#### **GBDT**

梯度提升**Gradient Boosting**的基本思想是根据当前模型损失函数**负梯度**信息来训练新加入的弱分类器，然后将训练好的弱分类器以**累加**的形式结合到现有的模型中。

GBDT（梯度提升决策树）的核心思想：每一棵树学的是之前所有树结果和的残差，这个残差就是加上预测之后能得到真实值的累加量。



- [ ] [2-10-1  梯度提升和梯度下降有什么区别和联系？](#2-10-1)

两者都是在每一轮迭代中，利用损失函数相对于模型的负梯度方向的信息来对当前模型进行更新，只不过在梯度下降中，模型是以参数化的形式表示，从而模型的更新等价于参数的更新。

而在梯度提升中，模型并不需要参数化表示，而是直接定义在函数空间中，从而大大扩展了可以使用的模型种类。



- [ ] [2-10-2  你是如何理解Boosting和Bagging？他们有什么异同？](#2-10-2)

Bagging通过模型集成降低方差，提高弱分类器的性能。

Boosting通过模型集成降低偏差，提高弱分类器的性能。



|          | Bagging                | Boosting                |
| -------- | ---------------------- | ----------------------- |
| 降低     | 方差                   | 偏差                    |
| 训练     | 各个弱分类器可独立训练 | 弱分类器需要依次生成    |
| 典型方法 | 随机森林               | Adaboost，GBDT，XGBoost |
|          |                        |                         |



- [ ] [2-10-3  讲解GBDT的训练过程？](#2-10-3)

用每个样本的残差训练下一棵树，直到残差收敛到某个阈值以下，或者树的总数达到某个上限为止。

- [ ] [2-10-4  你觉得GBDT训练过程中哪些环节可以平行提升训练效率？](#2-10-4)

决策树内部局部并行。

- [ ] [2-10-5  GBDT的优点和局限性有哪些？](#2-10-5)

**优点**

（1）预测阶段计算速度块，树与树之间可并行化计算

（2）在分布稠密的数据集上，泛化能力和表达能力都很好

（3）采用决策树作为弱分类器使得GBDT模型具有较好的可解释性和鲁棒性，能够自动发现特征间的高阶关系，并且不需要对数据进行特殊的预处理如归一化等

**缺点**

（1）GBDT在高维稀疏的数据集上，表现不如支持向量机或者神经网络

（2）GBDT在处理文本分类特征问题上，优势不如在处理数值特征时明显

（3）训练过程需要串行训练，只能在决策树内容采用一些局部并行手段提高训练速度



- [ ] [2-10-6  GBDT是否对异常值敏感，为什么？](#2-10-6)

**GDBT对异常值敏感**。对于回归类的问题，如果采用平方损失函数。当出现异常值时，后续模型会对异常值关注过多。

- [ ] [2-10-7  如何防止GBDT过拟合？](#2-10-7)



- [ ] [2-10-8  在训练过程中哪些参数对模型效果影响比较大？这些参数造成影响是什么？](#2-10-8)



#### **k-means**

kmean的总体特点

- 基于划分的聚类方法
- 类别k事先指定
- 以欧式距离平方表示样本之间的距离
- 以中心或样本的均值表示类别
- 以样本和其所属类的中心之间的距离总和为最优化的目标函数
- 得到的类别是平坦的、非层次化的
- 算法是迭代算法，不能保证全局最优



- [ ] [2-11-1  简述kmeans建模过程？](#2-11-1)

  kmeans聚类是基于样本集合划分的聚类算法

  （1）首先随机选择k个样本点作为初始聚类中心

  （2）计算每个样本到类中心的距离，将样本逐个指派到与其最近的类中，得到一个聚类结果

  （3）更新每个类的样本的均值，作为新的中心

  （4）重复以上步骤，知道划分不再改变，收敛为止

  

  kmeans的算法复杂度是$O(mnk)$，其中m是样本位数，n是样本个数，k是类别个数。比层次聚类复杂度低。

  

- [ ] [2-11-2  Kmeans损失函数是如何定义？](#2-11-2)

  样本与所属类的中心之间的距离的总和为损失函数
  $$
  W(C) = \sum_{l=1}^k \sum_{C(i)=l} {||x_i - \overline{x}_l||}
  $$
  其中 $\overline{x}_l$ 是第 $l$ 个类的均值或中心。相似的样本被聚到同类时，损失函数值最小。但是这是一个组合优化问题，n个样本分到k个类，可能的分法数目是指数级的，NP难问题。采样迭代的方法求解。

  

- [ ] [2-11-3  你是如何选择初始类族的中心点？](#2-11-3)

  **初始类中心点的选择**

  （1）可以用层次聚类对样本进行聚类，得到k个类时停止。然后从每个类中选取一个与中心距离最近的点。

  **类别数k的选择**

  k值需要预先指定，而在实际应用中最优的k值是不知道的。解决这个问题的一个方法是尝试用不同的k值聚类，检验各自得到聚类结果的质量，推测最优的k值

  （1）一般地，类别数变小时，平均直径会增加；类别数变大超过某个值后，平均直径会不变；而这个值是最优的k值。实验时可以采用二分查找，快速找到最优的k值。

  

- [ ] [2-11-4  如何提升kmeans效率？](#2-11-4)

  kmeans时间复杂度 $O(nkt)$ n，k，t分别为样本数，聚类中心数，迭代轮次

  （1）我们可以使用kd树以及ball 树（数据结构）来提高k-means算法的效率。（KNN计算的优化）

  （2）并行计算

  

- [ ] [2-11-5  常用的距离衡量方法有哪些？他们都适用什么类型问题？](#2-11-5)

  见 2-2-3

- [ ] [2-11-6  Kmeans对异常值是否敏感？为什么？](#2-11-6)

  敏感，因为需要计算距离，使用传统的欧式距离度量方式。所以需要预处理离群点、数据归一化。

  

- [ ] [2-11-7  如何评估聚类效果？](#2-11-7)

  知乎：https://zhuanlan.zhihu.com/p/53840697

  （1）**纯度**（*Purity*）

  我们把每个簇中最多的类作为这个簇所代表的类，然后计算正确分配的类的数量，然后除以 $N$ 。
  $$
  (\Omega, \mathbb{C})=\frac{1}{N} \sum_{k} \max _{j}\left|\omega_{k} \cap c_{j}\right|
  $$
  其中 $\Omega=\left\{\omega_{1}, \omega_{2}, \ldots, \omega_{K}\right\}$ 是聚类结果的集合 $\omega_{k}$表示第k个聚类的集合；$\mathbb{C}=\left\{c_{1}, c_{2}, \ldots, c_{J}\right\}$ 是原始分类的集合，$c_j$表示第j个分类的集合。

  ![img](https://pic4.zhimg.com/v2-e19781ffa33cc60608fad3fa60d5769f_b.jpg)

  purity优点：方便计算，值在0~1之间；

  缺点：当簇的数量很多的时候，容易达到较高的纯度——特别是，如果每个文档都被分到独立的一个簇中，那么计算得到的纯度就会是1。因此，不能简单用纯度来衡量聚类质量与聚类数量之间的关系。

  

  （2）**归一化化互信息**（NMI, *Normalized Mutual Information*）

  NMI越大，聚类效果越好
  ![[公式]](https://www.zhihu.com/equation?tex=%5Ctext%7BNMI%7D%28%5COmega%2C+C%29+%3D+%5Cfrac%7BI%28%5COmega%3B+C%29%7D%7B%28H%28%5COmega%29%2BH%28C%29%2F2%29%7D%5C%5C)

  其中, ![[公式]](https://www.zhihu.com/equation?tex=I) 表示互信息(Mutual Information), H 为熵，当 ![[公式]](https://www.zhihu.com/equation?tex=+%5Clog) 取 2 为底时，单位为 bit，取 e 为底时单位为 nat。

  ![[公式]](https://www.zhihu.com/equation?tex=%5Cbegin%7Bsplit%7D+I%28%5COmega%3B+C%29+%26%3D%5Csum_%7Bk%7D%5Csum_%7Bj%7DP%28w_k+%5Ccap+c_j%29%5Clog+%5Cfrac%7BP%28w_k+%5Ccap+c_j%29%7D%7BP%28w_k%29P%28c_j%29%7D%5C%5C+%26%3D+%5Csum_%7Bk%7D%5Csum_%7Bj%7D%5Cfrac%7B%7Cw_k+%5Ccap+c_j%7C%7D%7BN%7D%5Clog+%5Cfrac%7BN%7Cw_k+%5Ccap+c_j%7C%7D%7B%7Cw_k%7C%7Cc_j%7C%7D+%5Cend%7Bsplit%7D%5C%5C)

  其中, ![[公式]](https://www.zhihu.com/equation?tex=P%28w_k%29%2CP%28c_j%29%2CP%28w_k+%5Ccap+c_j%29+) 可以分别看作样本 (document) 属于聚类簇 ![[公式]](https://www.zhihu.com/equation?tex=w_k) , 属于类别 ![[公式]](https://www.zhihu.com/equation?tex=c_j) , 同时属于两者的概率。第二个等价式子则是由概率的极大似然估计推导而来。

  ![[公式]](https://www.zhihu.com/equation?tex=%5Cbegin%7Bsplit%7D+H%28%5COmega%29+%26%3D+-%5Csum_%7Bk%7DP%28w_k%29%5Clog+P%28w_k%29%5C%5C+%26%3D+-%5Csum_%7Bk%7D+%5Cfrac%7B%7Cw_k%7C%7D%7BN%7D%5Clog+%5Cfrac%7B%7Cw_k%7C%7D%7BN%7D+%5Cend%7Bsplit%7D%5C%5C)互信息 ![[公式]](https://www.zhihu.com/equation?tex=I%28%5COmega%3B+C%29) 表示给定类簇信息 ![[公式]](https://www.zhihu.com/equation?tex=C) 的前提条件下,类别信息 ![[公式]](https://www.zhihu.com/equation?tex=%5COmega) 的增加量,或者说其不确定度的减少量。直观地,互信息还可以写出如下形式：

  ![[公式]](https://www.zhihu.com/equation?tex=I%28%5COmega%3B+C%29+%3D+H%28%5COmega%29+-+H%28%5COmega+%7C+C%29%5C%5C)

  

  （3）**兰德指数**（RI, *Rand Index*）能度量聚类过程中的假阳性和假阴性结果的惩罚

  兰德指数 (Rand index, RI), 将聚类看成是一系列的决策过程,即对文档集上所有 ![[公式]](https://www.zhihu.com/equation?tex=N%28N-1%29%2F2)个文档 (documents) 对进行决策。当且仅当两篇文档相似时,我们将它们归入同一簇中。

  Positive:

  - TP 将两篇相似文档归入一个簇 (同 - 同)
  - TN 将两篇不相似的文档归入不同的簇 (不同 - 不同)

  Negative:

  - FP 将两篇不相似的文档归入同一簇 (不同 - 同)
  - FN 将两篇相似的文档归入不同簇 (同- 不同) (worse)

  

  RI 则是计算「正确决策」的比率(精确率, accuracy).

  ![[公式]](https://www.zhihu.com/equation?tex=RI+%3D+%5Cfrac%7BTP%2BTN%7D%7BTP%2BFP%2BTF%2BFN%7D%3D%5Cfrac%7BTP%2BTN%7D%7BC%5E%7B2%7D_%7BN%7D%7D%5C%5C)

  （4）**熵**（Entropy）

  

- [ ] [2-11-8  超参数类的个数k如何选取？](#2-11-8)

  （1）**手肘法**

  尝试不同的K值，并将不同K值所对应的损失函数化成折线，横轴为K的取值，纵轴为误差平方和所定义的损失函数。K值越大，距离和越小。当K=K'时，存在一个拐点，像人的肘部。当 $K\in(1,K')$，曲线急速下降；当 $K>K'$，曲线趋于平稳。手肘法认为拐点就是K的最佳值。

  （2）**Gap Statistic**

  手肘法是一个经验方法，缺点是不够自动化。Gap Statistic方法的优点是，不需要肉眼判断，只需要找到最大Gap statistic对应的K即可。因此该方法适用于批量化作业。
  $$
  {\rm Gap}(K) = E({\rm log}D_k) - {\rm log}D_k
  $$
  当分为K簇时，对应的损失函数记为 $D_k$，$E({\rm log}D_k)$是 ${\rm log}D_k$ 的期望，通过蒙特卡洛模拟产生。$\text{Gap}(K) $ 的物理含义是随机样本的损失与实际样本的损失之差。当$\text{Gap}(K) $取最大时，是样本的损失应该相对较小。

  

- [ ] [2-11-9  Kmeans有哪些优缺点？是否有了解过改进的模型，举例说明？](#2-11-9)

  **优点**

  （1）对于大数据集，kmeans聚类算法相对是可伸缩和高效的，它的计算复杂度是$O(NKt)$ 接近线性，其中N是样本数，K是聚类的簇数，t是迭代的轮数。

  （2）尽管算法经常以局部最优解结束，但一般情况下达到的局部最优已经可以满足聚类的需求

  

  **缺点**

  （1）受初值和离群点的影响，每次的结果不稳定

  （2）结果通常不是全局最优而是局部最优解

  （3）无法很好地解决数据簇分布差别比较大的情况（比如一类是另一类样本数量的100倍）

  （4）不太适用于离散分类

  （5）K值需要人工预先确定，且该值和真实的数据分布未必吻合【最大缺点】

  （6）样本点只能被划分到单一的类中

  

  **如何对Kmeans进行调优**

  （1）数据归一化和离群点处理

  ​	Kmeans聚类本质上是一种基于欧式距离度量的数据划分方法，均值和方差大的维度对聚类结果产生决定性影响。未做归一化无法直接参与计算；离群点或少量噪声会对均值产生较大影响，导致中心偏移。

  （2）合理选择K值

  ​	手肘法、Gap Statistic（不需要肉眼判断，只需要找到最大Gap statistic对应的K）

  （3）采用核函数

  ​	核聚类。通过非线性映射，将输入空间中的数据点映射到高维的特征空间中，并在新的特征空间中进行聚类。非线性映射增加了数据点线性可分的概率，从而在经典的聚类算法失效的情况下，通过引入核函数可以达到更为准确的聚类效果

  

  **改进的模型**

  （1）kmeans++ （对初始值选择的改进）

  ​	原始的kmeans算法最开始随机选取数据集中K个点作为聚类中心，而kmeans++按照以下思想选取k个聚类中心：假设已经选取了n个初始聚类中心（0<n<k），则在选取第n+1个聚类中心时，距离当前n个聚类中心越远的点会有更高的概率被选为第n+1个聚类中心。在选取第一个聚类中心时同样通过随机的方法。这符合我们的直觉：聚类中心互相离得越远越好。后续步骤与kmeans一致。

  

  （2）ISODATA（K值不确定时）

  ​	ISODATA全称是 迭代自组织数据分析法。在kmeans算法中，聚类个数K值需要预先人为确定，并且在整个算法过程中无法更改。当遇到高维度、海量数据时，难以准确估计出K的大小。ISODATA的思想是：当属于某个类别的样本数过少时，把该类别去除（合并操作）；当属于某个类别的样本数过多、分散程度大时，把该类别分为两个子类别（分裂操作）。

  ​	缺点是需要制定的参数比较多，4个：预期聚类中心数目 $K_0$、每个类所要求的最少样本数目 $N_{min}$、最大方差 $\sigma$ 、两个聚类中心之间所允许最小距离 $D_{min}$。

  

  （3）模糊C均值，高斯混合模型

  ​	样本不划分到单一的类中，即软聚类。

  

- [ ] [2-11-10  试试证明kmeans算法的收敛性](#2-11-10)

  kmeans聚类属于启发式方法，不能保证收敛到全局最优，初始中心的选择会直接影响聚类结果。

  类中心在聚类过程中会发生移动，但是往往不会移动太大，因为在每一步，样本被分到与其最近的中心的类中。

  

- [ ] [2-11-11  除了kmeans聚类算法之外，你还了解哪些聚类算法？简要说明原理](#2-11-11)

  **层次聚类**（hierarchical clustering）假设类别之间存在层次结构，分为聚合（自下而上）和分裂（自上而下）两种方法。**聚合法**开始讲每个样本各自分到一个类；之后将相邻最近的两类合并（根据类间距离最小合并规则），建立一个新的类，重复此操作直到满足停止条件（类的个数达到阈值/类的直径超过阈值）；得到层次化的分类。**分裂法**开始讲所有样本分到一个类；之后将已有类中相距最远的样本分到两个新的类，重复此操作直到满足停止条件；得到层次化的分类。

  层次聚类算法复杂度：$O(n^3m)$ 其中n是样本个数，m是样本维数。

  

  **k-means聚类**是基于中心的聚类方法，通过迭代，将样本分到k个类别中，使得每个样本与其所属类的中心或均值最近；得到k个平坦的、非层次化的类别。

  基于密度的方法DBSCAN

  谱聚类

- [ ] kmeans初始化为什么要从数据中随机挑k个，可以生成k个随机点吗？

  不可以；如果是用随机值，可能某个簇在第一轮就没有任何节点，无法继续计算

  

#### **PCA降维** 



- [ ] [2-12-1  为什么要对数据进行降维？它能解决什么问题？](#2-12-1)

  高维（多变量）数据，很难观察变量的样本区分能力，也很难观察样本之间的关系。降维是将样本集合中的样本从高维空间转换到低维空间。假设样本原本存在于低维空间，或近似存在与低维空间，通过降维则可以更好地表示样本数据的结构，即更好地表示样本之间的关系。降维有线性降维和非线性降维。

  维度灾难

- [ ] [2-12-2  你是如何理解维度灾难？](#2-12-1)

  特征数量超过一定值的时候，分类器的效果反而下降。原因：特征数过多，过拟合

  

- [ ] [2-12-3  PCA主成分分析思想是什么？](#2-12-1)

  变量之间可能存在相关性，以致增加了分析的难度。考虑用少数不想管的变量来替代相关的变量，用来表示数据，并且要求能保留数据中的大部分信息。

  PCA利用正交变换把线性相关变量表示的观测数据转换为少数几个由线性无关变量表示的数据，线性无关的变量称为主成分。PCA属于降维方法。

  

- [ ] [2-12-4  如何定义主成分？](#2-12-1)

  协方差矩阵的特征向量

  

- [ ] [2-12-5  如何设计目标函数使得降维达到提取主成分的目的？](#2-12-1)

  PCA目标函数：最大化投影方差。因为方差表示新变量的信息量大小。

  

- [ ] [2-12-6  PCA有哪些局限性？如何优化](#2-12-1)

  （1）无法进行非线性降维

  ​	通过核映射对PCA进行扩展得到核主成分分析（KPCA）

  ​	通过流形映射的降维方法，比如等距映射、局部线性嵌入（LLE）、拉普拉斯特征映射等

  （2）无监督的，算法没有考虑数据的标签，只是把把元数据映射到方差比较大的方向

  ​	有监督的降维方法：线性判别分析 LDA

  

- [ ] [2-12-7  线性判别分析和主成分分析在原理上有何异同？在目标函数上有何区别和联系？](#2-12-1)

  PCA选择的是投影后数据方差最大的方向。由于PCA是无监督的，因此假设方差越大，信息量越多，用主成分来表示原始数据可以去除冗余的维度，达到降维。

  LDA选择的是投影后类内方差最小，类间方差最大的方向。其用到了类别标签信息，为了找到数据中具有判别性的维度，使得原始数据在这些方向投影后，不同类别尽可能区分开。



## **3、 深度学习**

#### **DNN**

- [ ] [3-1-1  描述一下神经网络？推倒反向传播公式？](#3-1-1)
- [ ] [3-1-2  讲解一下dropout原理？](#3-1-2)

在神经网络前向传播的时候，让某个神经元的激活值以一定的概率p停止工作，这样可以使模型泛化性更强，因为它不会太依赖某些局部的特征。



- [ ] [3-1-3  梯度消失和梯度膨胀的原因是什么？有什么方法可以缓解？](#3-1-3)

梯度消失（梯度弥散）的原因：

解决方法：



梯度爆炸的原因：

解决方法：

- [ ] [3-1-4  什么时候该用浅层神经网络，什么时候该选择深层网络](#3-1-4)
- [ ] [3-1-5  Sigmoid、Relu、Tanh激活函数都有哪些优缺点？](#3-1-5)

**Sigmoid**
$$
f(x) = \frac{1}{1+ exp(-x)} \\
f'(x) = f(x)(1-f(x))
$$
$$
\begin{aligned}
f'(z) &= (\frac{1}{1+e^{-z}})' 
\\
&= \frac{e^{-z}}{(1+e^{-z})^{2}} 
\\
&= \frac{1+e^{-z}-1}{(1+e^{-z})^{2}}  
\\
&= \frac{1}{(1+e^{-z})}(1-\frac{1}{(1+e^{-z})}) 
\\
&= f(z)(1-f(z))
\\
\end{aligned}
$$

优点：

缺点：（1）需要计算指数，速度慢（2）会产生梯度消失问题





**Tanh**
$$
f(x) = tanh(x) = \frac{e^x - e^{-x}}{e^x + e^{-x}} \\

f'(x) = 1 - (f(x))^2
$$
优点：

缺点：（1）需要计算指数，速度慢（2）会产生梯度消失问题



**Relu**
$$
f(x) = max(x,0) \\
\begin{equation}
f'(x)=\left\{
\begin{aligned}
    1,x>0 \\
    0,x\leq0 \\
\end{aligned}
\right.
\end{equation}
$$
优点：（1）从计算的角度上，sigmoid和tanh都需要计算指数，复杂度高，而ReLU只需要一个阈值就可以得到激活值

（2）ReLU的非饱和性可以有效解决梯度消失的问题，提供相对宽的激活边界

（3）ReLU的单侧抑制提供了网络的稀疏表达能力（防止过拟合）

缺点：（1）训练过程中会导致神经元死亡的问题

缺点：（1）训练过程中会导致神经元死亡的问题



**Leaky ReLU**
$$
\begin{equation}
f(x)=\left\{
\begin{aligned}
    x,x>0 \\
    ax,x\leq0 \\
\end{aligned}
\right.
\end{equation}
\\

f'(x)=\left\{
\begin{aligned}
    1,x>0 \\
    a,x\leq0 \\
\end{aligned}
\right.
$$
优点：实现单侧抑制，又保留了部分附体度信息以致不完全消失

缺点：a值需要人工选择





- [ ] [3-1-6  写出常用激活函数的导数](#3-1-6)

见上

- [ ] [3-1-7  训练模型的时候，是否可以把网络参数全部初始化为0？为什么](#3-1-7)

不可以；参数全部为0时，网络不同神经元的输出必然相同，相同输出则导致梯度更新完全一样，会使得更新后的参数仍然保持完全相同。从而使得模型无法训练。



- [ ] [3-1-8  Batchsize大小会如何影响收敛速度？](#3-1-8)



#### **CNN**

- [ ] [3-2-1  简述CNN的工作原理？](#3-2-1)

CNN利用了图像的三个性质：

（1）图像的pattern通常比整张图像小

（2）通用的patterns会出现在图像的不同区域

（3）对图像进行子采样并不影响图像的识别

CNN通过卷积层+pooling层不断堆积，从小的pattern开始不断识别到大的pattern，从而识别整张图像。

> CNN适合处理什么问题

具有以上三个特性的问题

- [ ] [3-2-2  卷积核是什么？选择大卷积核和小卷积核有什么影响？](#3-2-2)
- [ ] [3-2-3  你在实际应用中如何设计卷积核？](#3-2-3)
- [ ] [3-2-4  为什么CNN具有平移不变性？](#3-2-4)

参数共享



- [ ] [3-2-5  Pooling操作是什么？有几种？作用是什么？](#3-2-5)





- [ ] [3-2-6  为什么CNN需要pooling操作？](#3-2-6)
- [ ] [3-2-7  什么是batchnormalization？它的原理是什么？在CNN中如何使用？](#3-2-7)
- [ ] [3-2-8  卷积操作的本质特性包括稀疏交互和参数共享，具体解释这两种特性以其作用？](#3-2-8)

**稀疏交互**：每个神经元的只跟上一层的某些神经元连接（vs DNN全连接），用到较少参数

**参数共享**：同一层的不同神经元之间共享部分权重，用到比原来更少的参数



- [ ] [3-2-9  你是如何理解fine-tune？有什么技巧](#3-2-9)

- [ ] [3-2-10  怎么观察CNN每个神经元学到了什么](#3-2-10)

假设第k个filter是一个11 x 11 的矩阵（一个神经元），可以用以下系数来表示第k个filter被激活的程度
$$
a^k = \sum_{i=1}^{11} \sum_{i=1}^{11} a_{ij}^k
$$
并通过梯度上升找到使 $a^k$ 最大的x，该x表示的图像表示该filter对应的检测纹路。
$$
x^* = \mathop{arg \ \rm max}\limits_{x}  \ a^k
$$


#### **RNN**

- [ ] [3-3-1  简述RNN模型原理，说说RNN适合解决什么类型问题？为什么](#3-3-1)

  RNN能够很好地处理文本数据变长并且有序的输入序列。它模拟了人阅读一篇文章的顺序，从前到后阅读文章中的每一个单词，将前面阅读到的有用信息编码到状态变量中去，从而拥有一定的记忆能力，可以更好地理解之后的文本。



- [ ] [3-3-2  RNN和DNN有何异同？](#3-3-2)

  相同点：一个长度为T的序列用xun

  不同点：RNN的循环性，序列的每个时刻都执行相同的任务，每个时刻的输出依赖于当前时刻的输入和上一时刻的隐藏状态

- [ ] [3-3-3  RNN为什么有记忆功能？](#3-3-3)

  RNN是包含循环的网络，将前面输入的有用信息编码到状态变量中去，从而拥有了一定的记忆功能。

- [ ] [3-3-4  长短期记忆网络LSTM是如何实现长短期记忆功能的？](#3-3-4)

  LSTM可以对有价值的信息进行长期记忆。

  与RNN不同的是，LSTM记忆单元c的转移不一定完全取决于激活函数计算得到的状态，还由输入门和遗忘门共同控制。

  在一个训练好的LSTM模型中，当输入序列中没有重要信息时，遗忘门的值接近于1，输入门的值接近于0，表示过去的记忆被完整保存，而输入信息被放弃，从而实现长期记忆功能。

  当输入序列中存在重要信息时，LSTM应把他存入记忆中，此时输入门接近于1；

  当输入序列中存在重要信息且该信息意味着之前的记忆不再重要时，输入门的值接近1，遗忘门的值接近0。

  

- [ ] [3-3-5  长短期记忆网络LSTM各模块都使用什么激活函数，可以使用其他激活函数么？](#3-3-5)

  百面p245。输入门、输出门、遗忘门使用sigmoid函数作为激活函数；在生成候选记忆时，使用双曲正切函数Tanh作为激活函数。

  首先这两个激活函数都是饱和的，如果使用非饱和函数如ReLU，将难以实现门控的效果。

  sigmoid作为门控信号的原因：sigmoid函数的输出在0~1之间，符合门控的物理定义。并且是饱和的，当输入较大或者较小时，其输出会非常接近1或0，从而保证该门的开或关。

  Tanh用于生成候选记忆的原因：输出在 -1~1之间，这与大多数场景下特征分布式以0为中心相吻合；并且Tanh函数在输入为0附近相比sigmoid有更大的梯度，通常使模型收敛更快。

  

- [ ] [3-3-6  GRU和LSTM有何异同](#3-3-6)

  GRU：将遗忘门和输入门合成了一个单一的更新门。同样还混合了细胞状态和隐藏状态，和其他一些改动。最终的模型比标准的 LSTM 模型要简单，也是非常流行的变体。

  ![](https://upload-images.jianshu.io/upload_images/42741-dd3d241fa44a71c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp)
  reset gate $r_t$：计算候选隐层 $\tilde{h}_{t}$ 时用来控制需要 保留多少之前的记忆 $h_{t-1}$，比如如果 $r_t$ 为0，那么$\tilde{h}_{t}$只包含当前词的信息。

  update gate $z_t$：控制需要从前一时刻的隐藏层$h_{t-1}$中遗忘多少信息，需要加入多少当前 时刻的隐藏层信息 $\tilde{h}_{t}$，最后得到 $h_{t}$

  > 一般来说那些具有短距离依赖的单元reset gate比较活跃（如果 ![[公式]](https://www.zhihu.com/equation?tex=r_t) 为1，而 ![[公式]](https://www.zhihu.com/equation?tex=z_t) 为0 那么相当于变成了一个标准的RNN，能处理短距离依赖），具有长距离依赖的单元update gate比较活跃。

  **相同点**

  （1）都会有门操作，决定是否保留上时刻的状态，和是否接收此时刻的外部输入，LSTM 是用遗忘门（forget gate $f_t$）和输入门（input gate $i_t$）来做到的，GRU 则是只用了一个更新门（update gate $z_t$ ）

  （2）遗忘门或者更新门选择不重写（overwritten）内部的 memory，那么网络就会一直记住之前的重要特征，那么会对当前或者未来继续产生影响。缓解梯度消失。

  **不同点**

  （1）首先就是 LSTM 有一个输出门来控制 memory content 的曝光程度（exposure），而 GRU 则是直接输出。

  （2）另一点是要更新的 new memory content 的来源也不同。$\tilde{h}_{t}$会通过重置门（reset gate） 控制从$h_{t-1}$ 中得到信息的力度，而 $\tilde{c}_{t}$ 则没有，而是直接输入$h_{t-1}$。

  （3）相同个数参数的情况下，GRU 会比 LSTM 稍好一些

  

- [ ] [3-3-7  什么是Seq2Seq模型？该模型能解决什么类型问题？](#3-3-7)

  seq2seq模型是将一个序列信号，通过编码和解码生成一个新的序列信号，输入和输出序列的长度实现并不知道。seq2seq的模型的核心思想由编码输入和解码输出两个环节构成。在经典的实现中，编码器和解码器各由一个循环神经网络构成，两个循环神经网络是共同训练的。

  解决问题：机器翻译、语音识别、自动对话

- [ ] [3-3-8  注意力机制是什么？Seq2Seq模型引入注意力机制主要解决什么问题？](#3-3-8)

  主要解决问题：

  （1）随着输入序列增长，模型性能发生显著下降。

  ​		因为编码时驶入序列的全部信息压缩到了一个向量表示中。随着序列增长，句子越前面的词的信息丢失就越严重。

  （2）seq2seq输出序列中，常常会损失部分输入序列的信息。

  ​		这是因为在解码时，当前词及对应的源语言词的上下文信息和位置信息在编解码过程中丢失了。

- [ ] [RNN的长期依赖（Long-Term Dependencies）问题是什么？怎么解决]()

  长期依赖问题是：随着输入序列的增长，模型的性能发生显著下降，RNN难以捕捉长距离输入之间的依赖。

  从结构上来看，理论上RNN可以学习捕捉到长距离依赖，但是实践中使用BPTT算法学习的RNN并不能成功捕捉长距离的医疗关系，主要源于深度神经网络中的**梯度消失**。

  解决方法：

  （1）LSTM、GRU等模型加入门控机制，捕捉长期记忆，很大程度上弥补了梯度消失

  （2）

  

- [ ] [RNN为什么会产生梯度消失或者梯度爆炸]()

  

- [ ] [RNN如何解决梯度爆炸问题]()

  梯度截断：对梯度值进行缩放，使得梯度的模不超过 $\eta$。假设 $g$ 是梯度向量， $|g|>\eta$，那么
  $$
  g=\frac{\eta g}{|g|}
  $$
  
- [ ] [RNN如何解决梯度消失问题]()

  （1）LSTM、GRU等模型加入门控机制，捕捉长期记忆，很大程度上弥补了梯度消失

  （2）RNN+初始化权重矩阵为单位矩阵

- [ ] [LSTM的结构，每个门的作用，计算公式]()

  ![](https://upload-images.jianshu.io/upload_images/17477516-8ef0e22accfffd33.png?imageMogr2/auto-orient/)

  经典的LSTM中第t步计算公式为
  $$
  \begin{array}{l}{i_{t}=\sigma\left(W_{i} x_{t}+U_{i} h_{t-1}+b_{i}\right)} \\ {f_{t}=\sigma\left(W_{f} x_{t}+U_{j} h_{t-1}+b_{f}\right)} \\ {o_{t}=\sigma\left(W_{\sigma} x_{t}+U_{o} h_{t-1}+b_{o}\right)} \\ {\tilde{c}_{t}=\operatorname{Tanh}\left(W_{c} x_{t}+U_{c} h_{t-1}\right)} \\ {c_{t}=f_{t} \odot c_{t-1}+i_{t} \odot \tilde{c}_{t}} \\ {h_{t}=o_{t} \odot \tanh \left(c_{t}\right)}\end{array}
  $$

  - [ ] [LSTM变种有哪些]()

    “**peephole connection**”：让 门控层 也会接受细胞状态的输入。

    ![](https://upload-images.jianshu.io/upload_images/42741-0f80ad5540ea27f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp)

    

    **coupled forget and input gates**：将输入门和遗忘们耦合在一起，输入和遗忘是同步的。

    ![](https://colah.github.io/posts/2015-08-Understanding-LSTMs/img/LSTM3-var-tied.png)

    **GRU**

## 4、 基础工具

#### **Spark**

- [ ] [4-1-1  什么是宽依赖，什么是窄依赖？哪些算子是宽依赖，哪些是窄依赖？](#4-1-1)
- [ ] [4-1-2  Transformation和action算子有什么区别？举例说明](#4-1-2)
- [ ] [4-1-3  讲解sparkshuffle原理和特性？shuffle write 和 huffleread过程做些什么？](#4-1-1)
- [ ] [4-1-4  哪些spark算子会有shuffle？](#4-1-1)
- [ ] [4-1-5  讲解sparkschedule（任务调度）？](#4-1-1)
- [ ] [4-1-6  Sparkstage是如何划分的？](#4-1-1)
- [ ] [4-1-7  Sparkcache一定能提升计算性能么？说明原因？](#4-1-1)
- [ ] [4-1-8  Cache和persist有什么区别和联系？](#4-1-1)
- [ ] [4-1-9  RDD是弹性数据集，“弹性”体现在哪里呢？你觉得RDD有哪些缺陷？](#4-1-1)
- [ ] [4-1-10  当GC时间占比很大可能的原因有哪些？对应的优化方法是？](#4-1-1)
- [ ] [4-1-11  park中repartition和coalesce异同？coalesce什么时候效果更高，为什么](#4-1-1)
- [ ] [4-1-12  Groupbykey和reducebykey哪个性能更高，为什么？](#4-1-1)
- [ ] [4-1-13  你是如何理解caseclass的？](#4-1-1)
- [ ] [4-1-14  Scala里trait有什么功能，与class有何异同？什么时候用trait什么时候用class](#4-1-1)
- [ ] [4-1-15  Scala 语法中to 和 until有啥区别](#4-1-1)
- [ ] [4-1-16  讲解Scala伴生对象和伴生类](#4-1-1)





#### **Xgboost**

- [ ] [4-2-1  你选择使用xgboost的原因是什么？](#4-2-1)

xgboos的优点：

1. 速度非常快
2. XGBoost支持多种类型的基分类器，比如线性分类器
3. XGBoost采用了多种策略防止过拟合：（1）目标函数正则项相当于预剪枝（2）每轮迭代支持数据行采样（bagging），还有列采样
4. 对缺失值自动处理





- [ ] [4-2-2  Xgboost和GBDT有什么异同？](#4-2-2)

1. GBDT是机器学习算法，XGBoost是该算法的工程实现
2. 传统GBDT以CART作为基分类器，XGBoost还**支持线性分类器**，这个时候XGBoost相当于带L1和L2正则化项的Logistic回归（分类问题）或者线性回归（回归问题）。
3. 传统的GBDT只用了一阶导数信息（使用牛顿法的除外），而XGBoost对损失函数做了**二阶泰勒展开**。并且XGBoost支持自定义损失函数，只要损失函数一阶、二阶可导。
4. 在使用CART作为基分类器时，XGBoost的目标函数多了**正则项**控制模型复杂度， 相当于**预剪枝**，使得学习出来的模型更加不容易过拟合。
5. 传统的GBDT在每轮迭代时使用全部数据，XGBoost则采用了与随机森林相似的策略，支持对数据进行采样（**行采样和列采样**）。
6. **对缺失值的处理**。传统的GBDT没有涉及对缺失值进行处理，XGBoost能够自动学习出缺失值的处理策略。
7. XGBoost工具**支持并行**。当然这个并行是在**特征的粒度**上，而非tree粒度，因为本质还是boosting算法。我们知道，决策树的学习最耗时的一个步骤是对特征的值进行排序（因为要确定最佳分割点）。xgboost在训练之前，预先对数据进行了排序，然后保存为block结构，后面的迭代中重复地使用这个结构，大大减小计算量。这个block结构也使得并行成为可能。在进行节点分裂时，需要计算每个特征的增益，最终选增益最大的那个特征去做分裂，那么各个特征的增益计算就可以开多线程进行。
8. 可并行的近似直方图计算。



- [ ] [4-2-3  为什么xgboost训练会那么快，主要优化点是什么？](#4-2-3)

1. 当数据集大的时候使用**近似算法**：在特征分裂时，根据特征k的分布确定$l$个候选切分点。根据这些切分点把相应的样本放入对应的桶中，对每个桶的$G,H$进行累加，最后通过遍历所有的候选分裂点来找到最佳分裂点。我们对这么多个桶进行分支判断，显然比起对n个样本找分裂节点更快捷。
2. Block与并行。分块并行，针对的是寻找最优切分点的过程中的排序部分。
3. CPU cache 命中优化。对于exact greedy算法中, 使用**缓存预取**。具体来说，对每个线程分配一个连续的buffer，读取梯度信息并存入Buffer中（这样就实现了非连续到连续的转化），然后再统计梯度信息。
4. Block预取、Block压缩、Block Sharding等



- [ ] [4-2-4  Xgboost是如何处理缺失值的？](#4-2-4)

XGBoost能对缺失值自动进行处理，其思想是**对于缺失值自动学习出它该被划分的方向**（左子树or右子树）: 

![](https://www.hrwhisper.me/wp-content/uploads/2018/07/XGBoost-sparsity-aware-split-finding.png)

注意，**上述的算法只遍历非缺失值**。划分的方向怎么学呢？很naive但是很有效的方法：

1. 让特征k的所有缺失值的都到右子树，然后和之前的一样，枚举划分点，计算最大的gain
2. 让特征k的所有缺失值的都到左子树，然后和之前的一样，枚举划分点，计算最大的gain

这样最后求出最大增益的同时，也知道了缺失值的样本应该往左边还是往右边。使用了该方法，相当于比传统方法多遍历了一次，但是它只在非缺失值的样本上进行迭代，因此其复杂度与非缺失值的样本成线性关系。

- [ ] [4-2-5  Xgboost和lightGBM有哪些异同？](#4-2-5)

![img](https://www.hrwhisper.me/wp-content/uploads/2018/07/LightGBM-VS-XGBoost.png)

不同点：

1. 由于在决策树在每一次选择节点特征的过程中，要遍历所有的属性的所有取值并选择一个较好的。**XGBoost**使用的是近似算法，**先对特征值进行排序**Pre-sort，然后根据二阶梯度进行分桶，能够更精确地找到数据分割点；但是复杂度较高。

   **LightGBM**使用的是**直方图算法**，只需要将数据分割成不同的段即可，不需要进行预先的排序。占用内存更低，数据分隔的复杂度更低**。**

2. **决策树的生长策略**

   XGBoost使用的是Level-wise的树生长策略；LightGBM使用的是leaf-wise的生长策略。

   在XGBoost中，树是按层生长的，称为**Level**-wise tree growth，同一层的所有节点都做分裂，最后剪枝，如下图所示：

   ![img](https://www.hrwhisper.me/wp-content/uploads/2018/07/LightGBM-level-wise-tree-growth.png)

   > Level-wise过一次数据可以同时分裂同一层的叶子，容易进行多线程优化，也好控制模型复杂度，不容易过拟合。但实际上Level-wise是一种低效的算法，因为它不加区分的对待同一层的叶子，带来了很多没必要的开销，因为实际上很多叶子的分裂增益较低，没必要进行搜索和分裂。

   而LightGBM采用的是**Leaf**-wise tree growth：

   > Leaf-wise则是一种更为高效的策略，每次从当前所有叶子中，找到分裂增益最大的一个叶子，然后分裂，如此循环。因此同Level-wise相比，在分裂次数相同的情况下，Leaf-wise可以降低更多的误差，得到更好的精度。Leaf-wise的缺点是可能会长出比较深的决策树，产生过拟合。因此LightGBM在Leaf-wise之上增加了一个最大深度的限制，在保证高效率的同时防止过拟合。

   ![](https://www.hrwhisper.me/wp-content/uploads/2018/07/LightGBM-leaf-wise-tree-growth.png)

3. **并行策略**

   XGBoost的并行主要集中在特征并行上，而LightGBM的并行策略分特征并行，数据并行以及投票并行。



- [ ] [4-2-6  Xgboost为什么要使用泰勒展开式，解决什么问题？](#4-2-6)

简短来说，就是为了**统一损失函数求导的形式以支持自定义损失函数**。

作者原回答

> 因为这样做使得我们可以很清楚地理解整个目标是什么，并且一步一步推导出如何进行树的学习。这一个抽象的形式对于实现机器学习工具也是非常有帮助的。传统的GBDT可能大家可以理解如优化平法残差，但是这样一个形式包含可所有可以求导的目标函数。也就是说有了这个形式，我们写出来的代码可以用来求解包括回归，分类和排序的各种问题，**正式的推导可以使得机器学习的工具更加一般**。

实际上使用二阶泰勒展开是为了xgboost能够【自定义loss function】，如果按照最小二乘法的损失函数直接推导，同样能够得到xgboost最终的推导式子：

![w_j^* = - \frac {G_j} {H_j + \lambda} \quad Obj = - \frac 1 2 \sum_{j=1}^T \frac {G_j^2} {H_j + \lambda} + \gamma T](https://www.zhihu.com/equation?tex=w_j%5E%2A+%3D+-+%5Cfrac+%7BG_j%7D+%7BH_j+%2B+%5Clambda%7D+%5Cquad+Obj+%3D+-+%5Cfrac+1+2+%5Csum_%7Bj%3D1%7D%5ET+%5Cfrac+%7BG_j%5E2%7D+%7BH_j+%2B+%5Clambda%7D+%2B+%5Cgamma+T)

二阶泰勒展开实际不是 ![\approx](https://www.zhihu.com/equation?tex=%5Capprox) 最小二乘法，平方损失函数的二阶泰勒展开=最小二乘法。但作者为何想用二阶泰勒展开呢，一种猜想为了xgboost库的可扩展性，**因为任何损失函数只要二阶可导即能【复用】文章中的的任何推导**。而且泰勒的本质是尽量去模仿一个函数，我猜二阶泰勒展开已经足以近似大量损失函数了，典型的还有基于分类的对数似然损失函数。嘿，这样同一套代码就能完成回归或者分类了，而不是每次都推导一番，重写训练代码。



- [ ] [4-2-7  Xgboost是如何寻找最优特征的？](#4-2-7)

通常采用贪心法，每次尝试分裂一个叶节点，**计算分裂后的增益**，选增益最大的。这个方法在之前的决策树算法中大量被使用。而增益的计算方式比如ID3的信息增益，C4.5的信息增益率，CART的Gini系数等。那XGBoost呢？

XGBoost使用下面的公式计算增益：
$$
Gain = \frac{1}{2}[\underbrace{\frac{G_L^2}{H_L+\lambda}}_{左子树分数} + \underbrace{\frac{G_R^2}{H_R+\lambda}}_{右子树分数} – \underbrace{\frac{(G_L+G_R)^2}{H_L+H_R+\lambda}}_{分裂前分数}] – \underbrace{\gamma}_{新叶节点复杂度}\tag{2-9}
$$
**分裂后 – 分裂前**的分数。**Gain值越大，说明分裂后能使目标函数减少越多，就越好**。在寻找最优分裂点时，遍历得到增益最大的点作为分裂点。注意分裂不一定会使情况变好，因为有一个引入新叶子的惩罚项 $\gamma$，优化这个目标相当于进行树的剪枝。当引入的分裂带来的增益小于一个阀值的时候，不进行分裂操作。

- [ ] [4-2-8 Xgboost的缺点？](#4-2-8)

1. 空间开销大。需要保存数据的特征值。XGBoost采用Block结构，存储指向样本的索引，需要消耗两倍的内存。
2. 时间开销大（相对于lightGBM而言）。在寻找最优切分点时，要对每个特征都进行排序，还要对每个特征的每个值都进行了遍历，并计算增益。
3. 对Cache不友好（相对于lightGBM而言）。使用Block块预排序后，特征对梯度的访问是按照索引来获取的，是一种随机访问，而不同特征访问顺序也不一样，容易照成命中率低的问题。同时，在每一层长树的时候，需要随机访问一个行索引到叶子索引的数组，并且不同特征访问的顺序也不一样，也会造成较大的Cachemiss。



#### **Tensorflow**

- [ ] [4-3-1  使用tensorflow实现逻辑回归，并介绍其计算图](#4-3-1)
- [ ] [4-3-2  sparse_softmax_cross_entropy_with_logits和softmax_cross_entropy_with_logits有何异同？](#4-3-2)
- [ ] [4-3-3  使用tensorflow过程中，常见调试哪些参数？举例说明](#4-3-3)
- [ ] [4-3-4  Tensorflow梯度更新是同步还是异步，有什么好处？](#4-3-4)
- [ ] [4-3-5  讲解一下TFRecords](#4-3-5)
- [ ] [4-3-6  tensorflow如何使用如何实现超大文件训练？](#4-3-6)
- [ ] [4-3-7  如何读取或者加载图片数据？](#4-3-7)



## **5、推荐系统**

- [ ] [5-1-1  你是如何选择正负样本？如何处理样本不均衡的情况？](#5-1-1)

样本不均衡处理：

1）上采样和子采样；2）修改权重（修改损失函数）；3）集成方法：bagging，类似随机森林、自助采样；4）多任务联合学习；



- [ ] [5-1-2  如何设计推荐场景的特征体系？举例说明](#5-1-1)
- [ ] [5-1-3  你是如何建立用户模型来理解用户，获取用户兴趣的？](#5-1-1)
- [ ] [5-1-4  你是如何选择适合该场景的推荐模型？讲讲你的思考过程](#5-1-1)
- [ ] [5-1-5  你是如何理解当前流行的召回->粗排->精排的推荐架构？这种架构有什么优缺点？什么场景适用使用，什么场景不适合？](#5-1-1)
- [ ] [5-1-6  如何解决热度穿透的问题？（因为item热度非常高，导致ctr类特征主导排序，缺少个性化的情况）](#5-1-1)
- [ ] [5-1-7  用户冷启动你是如何处理的？](#5-1-1)
- [ ] [5-1-8  新内容你是如何处理的？](#5-1-1)
- [ ] [5-1-9  你们使用的召回算法有哪些？如何能保证足够的召回率？](#5-1-1)
- [ ] [5-1-10  实时数据和离线数据如何融合？工程上是怎样实现？如何避免实时数据置信度不高带来的偏差问题？](#5-1-1)
- [ ] [5-1-11  你们是如何平衡不同优化目标的问题？比如：时长、互动等](#5-1-1)
- [ ] [5-1-12  不同类型内容推荐时候，如何平衡不同类型内容，比如图文、视频；或者不同分类](#5-1-1)
- [ ] [5-1-13  如何保证线上线下数据一致性？工程上是如何实现？](#5-1-1)
- [ ] [5-1-14  离线训练效果好，但是上线效果不明显或在变差可能是什么问题？如何解决？](#5-1-1)
- [ ] [5-1-15  在实际业务中，出现badcase,你是如何快速反查问题的？举例说明](#5-1-1)
- [ ] [5-1-16  使用ctr预估的方式来做精排，会不会出现相似内容大量聚集？原因是什么？你是如何解决的？](#5-1-1)
- [ ] [5-1-17  你了解有多少种相关推荐算法？各有什么优缺点](#5-1-1)



|               | 优点                     | 缺点                       | 适用场景                                       |
| ------------- | ------------------------ | -------------------------- | ---------------------------------------------- |
| item-based CF | 注重个性化，发掘长尾商品 | 推荐结果过于热门，需要惩罚 | item更新频率低的（如购物网站、图书、电影网站） |
| user-based CF | 社交网络                 |                            | item更新频率高（新闻）                         |
|               |                          |                            |                                                |

l

- [ ] [5-1-18  深度学习可以应用到推荐问题上解决哪些问题？为什么比传统机器学习要好？](#5-1-1)



# **二、数学相关**

## **6、 概率论和统计学**

- [ ] [6-1-1  说说你是怎样理解信息熵的？](#6-1-1)
- [ ] [6-1-2   能否从数据原理熵解析信息熵可以表示随机变量的不确定性？](#6-1-2)
- [ ] [6-1-3  怎样的模型是最大熵模型？它有什么优点](#6-1-3)
- [ ] [6-1-4  什么是Beta分布？它与二项分布有什么关系？](#6-1-4)
- [ ] [6-1-5   什么是泊松分布？它与二项分布有什么关系？](#6-1-5)
- [ ] [6-1-6  什么是t分布？他与正态分布有什么关系？](#6-1-6)
- [ ] [6-1-7   什么是多项式分布？具体说明？](#6-1-7)
- [ ] [6-1-8   参数估计有哪些方法？](#6-1-8)
- [ ] [6-1-9  点估计和区间估计都是什么？](#6-1-9)
- [ ] [6-1-10  讲解一下极大似然估计，以及适用场景？](#6-1-10)
- [ ] [6-1-11  讲解一下最后后验概率估计，以及适用场景？](#6-1-10)

**极大似然估计中采样需满足一个重要的假设，就是所有的采样都是独立同分布的。**

那么我们就知道了极大似然估计的核心关键就是对于一些情况，样本太多，无法得出分布的参数值，可以采样小样本后，利用极大似然估计获取假设中分布的参数。

极大似然估计就是经验风险最小化的一个例子。当模型是条件概率分布、损失函数是对数损失函数时，经验风险最小化就等价于极大似然估计。

最大后验概率是计算给定数据条件下模型的条件概率，即后验概率。使用模型的先验分布是贝叶斯学习的特点。

- [ ] [频率学派和贝叶斯学派什么区别？]()

  频率学派是上帝视角，认为频率是固定的，比如硬币均匀投掷之后正面概率为0.5，但贝叶斯学派是观察者的身份，会随着观察结果更新认知。

- [ ]  大数定理和中心极限定理
- [ ] 

## 7、 最优化问题

- [ ] [7-1-1  什么是梯度？](#7-1-1)

- [ ] [7-1-2  梯度下降找到的一定是下降最快的方法？](#7-1-1)

- [ ] [7-1-3  牛顿法和梯度法有什么区别？](#7-1-1)

- [ ] [7-1-4  什么是拟牛顿法？](#7-1-1)

- [ ] [7-1-5  讲解什么是拉格朗日乘子法、对偶问题、kkt条件?](#7-1-1)

  **凸优化问题**

  

- [ ] 拉格朗日乘子法

  **对偶问题**

  将极小极大的原问题转为极大极小的对偶问题；通常对偶问题更好求解，可以通过求解对偶问题而得到原始问题的解，进而确定分离超平面和决策函数（SVM）。

  **KKT条件**

  

- [ ] 

- [ ] 

- [ ] [7-1-6  是否所有的优化问题都可以转化为对偶问题？](#7-1-1)

  对所有实数域上的优化问题都有其对偶问题

  

- [ ] [7-1-7  讲解SMO（SequentialMinimalOptimization）算法基本思想？](#7-1-1)

  SMO（序列最小优化算法）是一种启发式算法，是支持向量机学习的一种快速算法，其特点是不断地将原二次规划问题分解为只有两个变量的二次规划子问题，并对子问题进行解析求解，直到所有变量满足KKT条件为止，这时这个最优化问题的解就得到了。这样通过启发式的方法得到原二次规划问题的最优解。因为子问题有解析解，所以每次计算子问题都很快，虽然计算子问题次数很多，但在总体上还是高效的。

  整个SMO算法包括两部分：（1）求解两个变量二次规划的解析方法（2）选择变量的启发式方法

  

- [ ] [7-1-8  为什么深度学习不用二阶优化？](#7-1-1)

- [ ] [7-1-9  讲解SGD，ftrl、Adagrad，Adadelta，Adam，Adamax，Nadam优化算法以及他们的联系和优缺点](#7-1-1)

- [ ] [7-1-10 为什么batch size大，训练速度快or为什么mini-batch比SGD快？](#7-1-10)

（1）从矩阵计算角度

mini-batch不同的输入可以拼成一个矩阵，和W计算矩阵相乘可以并行地计算，比SGD一个一个计算快。对于GPU，矩阵相乘可以并行地处理，速度快。

- [ ] [7-1-11  7-1-11  为什么不把batch size设得特别大](7-1-11)

（1）GPU内存限制

（2）性能差；容易卡在局部极小值  





